{
    "docs": [
        {
            "location": "/", 
            "text": "module changes\n\n\nThe following modules are deprecated\n\nschrodinger\n.\ntrajectory\n\n\nschrodinger\n.\ninfra\n.\ndesmond\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\ndestro\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\nperiodicfix\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\nframesettools\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\ngenerictrajectory\n\n\n\n\n\n\nThe replacements are\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ntopo\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ntraj\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\nanalysis\n\n\n(\nthe\n \nnew\n \ndestro\n)\n\n\n\n\n\n\nanalyzers in the new trajectory infrastructure\n\n\n\n\nbasic geometric operations\n\n\nAngle\n\n\nDistance\n\n\nTorsion\n\n\nVector\n\n\n\n\n\n\nCenterOf\n\n\nCentroid\n\n\nCoC\n: center of charge\n\n\nCom\n: center of mass\n\n\n\n\n\n\nDipole\n\n\nGyradius\n: radius of gyration\n\n\nHydrogenBondFinder\n\n\nMassAvgVel\n: mass-averaged velocity\n\n\nMolecularSurfaceArea\n\n\nMomentOfInertia\n\n\nOrderParameter\n\n\nthe following analyzers are inputs to \nOrderParameter\n\n\nAxisDirector\n\n\nDipoleDirector\n\n\nLipidDirector\n\n\nsn1\n\n\nsn2\n\n\nall\n\n\n\n\n\n\nMomentOfInertiaDirector\n\n\nSmartsDirector\n\n\nSystemDipoleDirector\n\n\n\n\n\n\n\n\n\n\nPolarSurfaceArea\n\n\nPosAlign\n: align positions\n\n\nRMSD\n: Root mean square deviation\n\n\nLigandRMSD\n: further includes symmetry consideration\n\n\n\n\n\n\nRMSF\n: Root mean square fluctuation\n\n\nProteinRMSF\n\n\n\n\n\n\nCovarianceMatrix\n\n\n\n\n\n\nPosTrack\n: track positions of selected atoms in a trajectory\n\n\nProtLigInter\n: Protein-ligand interactions\n\n\nHydrophobicInter\n, `_HydrophobicInter\n\n\nMetalInter\n\n\nProtLigHbondInter\n\n\nProtLigPiInter\n\n\nProtLigPolarInter\n, \n_ProtLigPolarInter\n\n\nWaterBridges\n\n\nWatLigFragDistance\n, \n_WatLigFragDistance\n\n\n\n\n\n\nProtProtInter\n: Protein-protein interactions\n\n\nProtProtHbondInter\n\n\nProtProtPiInter\n\n\nProtProtSaltBridges\n\n\n\n\n\n\nRdf\n: Radial distribution function\n\n\nRamachandran\n\n\nSecondaryStructure\n\n\nSaltBridgeFinder\n\n\nSolventAccessibleSurfaceArea\n\n\nSolventAccessibleSurfaceAreaByResidue\n\n\nVolumeMapper", 
            "title": "Home"
        }, 
        {
            "location": "/#module-changes", 
            "text": "The following modules are deprecated schrodinger . trajectory  schrodinger . infra . desmond  schrodinger . application . desmond . destro  schrodinger . application . desmond . periodicfix  schrodinger . application . desmond . framesettools  schrodinger . application . desmond . generictrajectory    The replacements are schrodinger . application . desmond . packages . topo  schrodinger . application . desmond . packages . traj  schrodinger . application . desmond . packages . analysis  ( the   new   destro )", 
            "title": "module changes"
        }, 
        {
            "location": "/#analyzers-in-the-new-trajectory-infrastructure", 
            "text": "basic geometric operations  Angle  Distance  Torsion  Vector    CenterOf  Centroid  CoC : center of charge  Com : center of mass    Dipole  Gyradius : radius of gyration  HydrogenBondFinder  MassAvgVel : mass-averaged velocity  MolecularSurfaceArea  MomentOfInertia  OrderParameter  the following analyzers are inputs to  OrderParameter  AxisDirector  DipoleDirector  LipidDirector  sn1  sn2  all    MomentOfInertiaDirector  SmartsDirector  SystemDipoleDirector      PolarSurfaceArea  PosAlign : align positions  RMSD : Root mean square deviation  LigandRMSD : further includes symmetry consideration    RMSF : Root mean square fluctuation  ProteinRMSF    CovarianceMatrix    PosTrack : track positions of selected atoms in a trajectory  ProtLigInter : Protein-ligand interactions  HydrophobicInter , `_HydrophobicInter  MetalInter  ProtLigHbondInter  ProtLigPiInter  ProtLigPolarInter ,  _ProtLigPolarInter  WaterBridges  WatLigFragDistance ,  _WatLigFragDistance    ProtProtInter : Protein-protein interactions  ProtProtHbondInter  ProtProtPiInter  ProtProtSaltBridges    Rdf : Radial distribution function  Ramachandran  SecondaryStructure  SaltBridgeFinder  SolventAccessibleSurfaceArea  SolventAccessibleSurfaceAreaByResidue  VolumeMapper", 
            "title": "analyzers in the new trajectory infrastructure"
        }, 
        {
            "location": "/fundamentals/", 
            "text": "The new trajectory infrastructure will do better with handling\n\n\n\n\nvirtual sites (pseudo atoms)\n\n\ntriclinic lattice\n\n\nunwrapping around periodic boundary condition automatically\n\n\n\n\nRoughly speaking, here are the correspondences:\n\n\n\n\n\n\n\n\nold\n\n\nnew\n\n\n\n\n\n\n\n\n\n\nDesmondSimulation\n or \nChorusSimulation\n object\n\n\nCms\n object and trajectory object\n\n\n\n\n\n\n_DesmondFrame\n object\n\n\ntraj.Frame\n object\n\n\n\n\n\n\nschrodinger.infra.desmond.Trajectory\n or \nframesettools.Frameset\n\n\npython list of \ntraj.Frame\n objects\n\n\n\n\n\n\n\n\nNote that \n\n\n\n\nThe new frame object is different from the old one. \n\n\n\n\nminimum examples\n\n\nTo read the cms input file\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_file_name\n)\n\n\n\n\n\n\nTo read a trajectory\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\n\n\n\n\nTo do some analysis using existing analyzers\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \nanalysis\n,\n \ntraj\n,\n \ntopo\n\n\n\n# load data\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nFNAME\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\nTRJ_FNAME\n)\n\n\n\n# define analyzers\n\n\nanalyzer1\n \n=\n \nanalysis\n.\nCom\n(\nmsys_model\n,\n \ncms_model\n,\n \nasl\n=\nm.n 1\n)\n\n\nanalyzer2\n \n=\n \nanalysis\n.\nProtLigInter\n(\nmsys_model\n,\n \ncms_model\n,\n \nprotein\n,\n \nm.n 2\n)\n\n\n\n# compute result\n\n\nresults\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n,\n \nanalyzer2\n,\n \n)\n\n\n\n\n\n\nThe \nresults\n is a list of the analyzer's output.\nEach output is a list of results for each trajectory frame.\n\n\natom AIDs and atom GIDs\n\n\nIn MD simulation, there are two types of atoms\n\n\n\n\nphysical atoms\n\n\npseudo atoms (virtual sites): They are used to model forcefield better.\n\n\n\n\nIn Maestro, the pseudo atoms are not displayed.\n\n\nTo keep track of the atoms, there are two types of IDs\n\n\n\n\nAID stands for Atom ID, defined as the atom index in the full system ct (it is the same as \ncms_model.atom.index\n).\n\n\nGID stands for Global ID, defined as the particle index in the Desmond internal particle array.\n\n\n\n\nNote that pseudo atoms do not have AID.\n\n\nTo access a particle's coordinate in the trajectory (i.e., the \ntraj.Frame\n object), you have to use GID. We have functions to map AID to GID in the \ntopo\n module. For example,\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_filename\n)\n\n\nprotein_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nprotein_asl\n)\n\n\nprotein_gids\n \n=\n \ntopo\n.\naids2gids\n(\ncms_model\n,\n \nprotein_aids\n,\n\n                              \ninclude_pseudoatoms\n=\nFalse\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nfr\n.\npos\n(\nprotein_gids\n)\n\n    \nfr\n.\nvel\n(\nprotein_gids\n)\n\n\n\n\nBoth \ntraj.Frame.pos()\n and \ntraj.Frame.vel()\n return Nx3 numpy arrays. Without argument input, they return the positions or velocities of all atoms.\n\n\nNote that\n\n\n\n\nvel()\n may not exist. Default MD simulation does not save velocities, also the XTC format trajectories do not contain velocities.\n\n\nIf you get positions this way, then you need to worry about unwrapping around PBC yourself. If you don't want to unwrap yourself, try use the existing mechanisms in the infrastructure. See paradigms below.\n\n\n\n\nASL and SMARTS evaluations only return AIDs. In other words, they only select physical atoms.", 
            "title": "Fundamentals"
        }, 
        {
            "location": "/fundamentals/#minimum-examples", 
            "text": "To read the cms input file import   schrodinger.application.desmond.packages.topo   as   topo  msys_model ,   cms_model   =   topo . read_cms ( cms_file_name )    To read a trajectory import   schrodinger.application.desmond.packages.traj   as   traj  tr   =   traj . read_traj ( trajectory_directory )    To do some analysis using existing analyzers  from   schrodinger.application.desmond.packages   import   analysis ,   traj ,   topo  # load data  msys_model ,   cms_model   =   topo . read_cms ( FNAME )  tr   =   traj . read_traj ( TRJ_FNAME )  # define analyzers  analyzer1   =   analysis . Com ( msys_model ,   cms_model ,   asl = m.n 1 )  analyzer2   =   analysis . ProtLigInter ( msys_model ,   cms_model ,   protein ,   m.n 2 )  # compute result  results   =   analysis . analyze ( tr ,   analyzer1 ,   analyzer2 ,   )   The  results  is a list of the analyzer's output.\nEach output is a list of results for each trajectory frame.", 
            "title": "minimum examples"
        }, 
        {
            "location": "/fundamentals/#atom-aids-and-atom-gids", 
            "text": "In MD simulation, there are two types of atoms   physical atoms  pseudo atoms (virtual sites): They are used to model forcefield better.   In Maestro, the pseudo atoms are not displayed.  To keep track of the atoms, there are two types of IDs   AID stands for Atom ID, defined as the atom index in the full system ct (it is the same as  cms_model.atom.index ).  GID stands for Global ID, defined as the particle index in the Desmond internal particle array.   Note that pseudo atoms do not have AID.  To access a particle's coordinate in the trajectory (i.e., the  traj.Frame  object), you have to use GID. We have functions to map AID to GID in the  topo  module. For example,  import   schrodinger.application.desmond.packages.topo   as   topo  import   schrodinger.application.desmond.packages.traj   as   traj  _ ,   cms_model   =   topo . read_cms ( cms_filename )  protein_aids   =   cms_model . select_atom ( protein_asl )  protein_gids   =   topo . aids2gids ( cms_model ,   protein_aids , \n                               include_pseudoatoms = False )  tr   =   traj . read_traj ( trajectory_directory )  for   fr   in   tr : \n     fr . pos ( protein_gids ) \n     fr . vel ( protein_gids )  \n\nBoth  traj.Frame.pos()  and  traj.Frame.vel()  return Nx3 numpy arrays. Without argument input, they return the positions or velocities of all atoms.  Note that   vel()  may not exist. Default MD simulation does not save velocities, also the XTC format trajectories do not contain velocities.  If you get positions this way, then you need to worry about unwrapping around PBC yourself. If you don't want to unwrap yourself, try use the existing mechanisms in the infrastructure. See paradigms below.   ASL and SMARTS evaluations only return AIDs. In other words, they only select physical atoms.", 
            "title": "atom AIDs and atom GIDs"
        }, 
        {
            "location": "/paradigms/", 
            "text": "load both cms file and trajectory\n\n\n    \nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nargs\n.\ncms_file\n)\n\n    \ntrj_path\n \n=\n \ntopo\n.\nfind_traj_path\n(\ncms_model\n,\n \nos\n.\npath\n.\ndirname\n(\nargs\n.\ncms_file\n))\n\n    \nif\n \ntrj_path\n \nis\n \nNone\n:\n\n        \nparser\n.\nerror\n(\nCould not locate a trajectory directory for given CMS file\n)\n\n    \ntry\n:\n\n        \ntrj\n \n=\n \ntraj\n.\nread_traj\n(\ntrj_path\n)\n\n    \nexcept\n \nException\n \nas\n \ne\n:\n\n        \nparser\n.\nerror\n(\nCannot load trajectory file: \n%s\n \n%\n \ne\n)\n\n\n\n\n\n\nextract structure once and per frame update coordinates instead of per frame update full system ct and extract structure\n\n\nNote that although one can get the full system ct per frame in new trajectory infrastructure, it is likely the inefficient approach. In most cases, the demand is not to track the full system ct over the frames, but track some specific group of atoms or molecules over the frames. In these situations, it is more efficient to \n\n\n\n\nextract the structure once\n\n\nkeep updating the coordinates of the structure frame by frame\n\n\n\n\nIf the analysis is fully geometric, then the structure extraction can be avoided as well.\n\n\nHere is an example\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_filename\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\nprotein_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nprotein_asl\n)\n\n\nprotein_gids\n \n=\n \ntopo\n.\naids2gids\n(\ncms_model\n,\n \nprotein_aids\n,\n\n                              \ninclude_pseudoatoms\n=\nFalse\n)\n\n\nprotein_st\n \n=\n \ncms_model\n.\nextract\n(\nprotein_aids\n)\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nprotein_st\n.\nsetXYZ\n(\nfr\n.\npos\n(\nprotein_gids\n))\n\n    \n# what needs to be done on the protein structure\n\n    \n...\n\n\n\n\n\n\nThis is better than\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_filename\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\nprotein_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nprotein_asl\n)\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nupdated_cms\n \n=\n \ntopo\n.\nupdate_fsys_ct\n(\ncms_model\n,\n \nfr\n)\n\n    \nprotein_st\n \n=\n \nupdated_cms\n.\nextract\n(\nprotein_aids\n)\n\n    \n# what needs to be done on the protein structure\n\n    \n...\n\n\n\n\n\n\ntry avoid unwrap coordinates around periodic boundary conditions yourself\n\n\nThere are mechanisms in the new trajectory infrastructure to do these unwrapping for you. The relevant analyzer classes are\n\n\n\n\nbasic geometric operations\n\n\nAngle\n\n\nDistance\n\n\nTorsion\n\n\nVector\n\n\n\n\n\n\nCenterOf\n\n\nCentroid\n\n\nCoC\n: center of charge\n\n\nCom\n: center of mass\n\n\n\n\n\n\n\n\nYou can even measure geometric quantity between (among) center of mass objects/atoms (see example below), etc.\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \nanalysis\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \ntraj\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \ntopo\n\n\n\n# load data\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nFNAME\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\nTRJ_FNAME\n)\n\n\n\n# define analyzers\n\n\nanalyzer1\n \n=\n \nanalysis\n.\nCom\n(\nmsys_model\n,\n \ncms_model\n,\n \nasl\n=\nmy_asl\n)\n\n\nana_vector\n \n=\n \nanalysis\n.\nVector\n(\nmsys_model\n,\n \ncms_model\n,\n \n1\n,\n \n10\n)\n\n\nanalyzer3\n \n=\n \nanalysis\n.\nProtLigInter\n(\nmsys_model\n,\n \ncms_model\n,\n \nprotein\n,\n \nm.n 2\n)\n\n\ns5\n \n=\n \nanalysis\n.\nCom\n(\nself\n.\nmsys_model\n,\n \nself\n.\ncms_model\n,\n \nasl\n=\nnot atom.num 17\n)\n  \n# this doesn\nt need to be passed to analysis.analyze\n\n\ndist_com_atm\n \n=\n \nanalysis\n.\nDistance\n(\nself\n.\nmsys_model\n,\n \nself\n.\ncms_model\n,\n \ns5\n,\n \n10\n)\n\n\n\n# compute result\n\n\nresults\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n,\n \nana_vector\n,\n \nanalyzer3\n,\n \ndist_com_atm\n)\n\n\n\n\n\n\nIf you have to unwrap yourself, use the \nanalysis.Pbc\n class. Also note that the simulation box may change from frame to frame, e.g. in NPT systems. Thus the \nanalysis.Pbc\n object needs to be updated frame by frame.\n\n\nNote that the \ncircular mean algorithm\n is used to calculate geometric centers.\nThus it will fail if both of the following conditions apply\n* the selected atoms have a spatial extent comparable to the simulation box\n* the selected atoms do not form a blob-like shape (e.g., dumbbell)\n\n\nanalyze all together instead of one by one\n\n\nIf multiple analyzers can share some intermediate calculations, \nthere is a good chance that the new trajectory analysis framework calculates these intermediate results only once.\nThus it is more efficient to call \nanalysis.analyze\n with all analyzers together instead of calling \nanalysis.analyze\n multiple times.\n\n\nThus\n\nresults\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n,\n \nanalyzer2\n,\n \nanalyzer3\n)\n\n\n\n\n\n\nis better than\n\nresult1\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n)\n\n\nresult2\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer2\n)\n\n\nresult3\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer3\n)\n\n\n\n\n\n\ntesting\n\n\nThe new trajectory modules are in the desmond package.\nThus if you are working on a non-desmond repo and uses trajectory stuff, test has to be written in the following way\n\n\n\n\nuse \ntest_marker.require_product('desmond')\n\n\nlazy import the trajectory handling modules\n\n\n\n\n# Lazy import, in case desmond is not installed\n\n\nmf\n \n=\n \nNone\n\n\n\n@pytest.fixture\n(\nscope\n=\nmodule\n,\n \nautouse\n=\nTrue\n)\n\n\ndef\n \nimport_my_file\n():\n\n    \nglobal\n \nmf\n\n    \nimport\n \nmy_file\n \nas\n \nmf", 
            "title": "Paradigms"
        }, 
        {
            "location": "/paradigms/#load-both-cms-file-and-trajectory", 
            "text": "msys_model ,   cms_model   =   topo . read_cms ( args . cms_file ) \n     trj_path   =   topo . find_traj_path ( cms_model ,   os . path . dirname ( args . cms_file )) \n     if   trj_path   is   None : \n         parser . error ( Could not locate a trajectory directory for given CMS file ) \n     try : \n         trj   =   traj . read_traj ( trj_path ) \n     except   Exception   as   e : \n         parser . error ( Cannot load trajectory file:  %s   %   e )", 
            "title": "load both cms file and trajectory"
        }, 
        {
            "location": "/paradigms/#extract-structure-once-and-per-frame-update-coordinates-instead-of-per-frame-update-full-system-ct-and-extract-structure", 
            "text": "Note that although one can get the full system ct per frame in new trajectory infrastructure, it is likely the inefficient approach. In most cases, the demand is not to track the full system ct over the frames, but track some specific group of atoms or molecules over the frames. In these situations, it is more efficient to    extract the structure once  keep updating the coordinates of the structure frame by frame   If the analysis is fully geometric, then the structure extraction can be avoided as well.  Here is an example  import   schrodinger.application.desmond.packages.topo   as   topo  import   schrodinger.application.desmond.packages.traj   as   traj  _ ,   cms_model   =   topo . read_cms ( cms_filename )  tr   =   traj . read_traj ( trajectory_directory )  protein_aids   =   cms_model . select_atom ( protein_asl )  protein_gids   =   topo . aids2gids ( cms_model ,   protein_aids , \n                               include_pseudoatoms = False )  protein_st   =   cms_model . extract ( protein_aids )  for   fr   in   tr : \n     protein_st . setXYZ ( fr . pos ( protein_gids )) \n     # what needs to be done on the protein structure \n     ...   This is better than  _ ,   cms_model   =   topo . read_cms ( cms_filename )  tr   =   traj . read_traj ( trajectory_directory )  protein_aids   =   cms_model . select_atom ( protein_asl )  for   fr   in   tr : \n     updated_cms   =   topo . update_fsys_ct ( cms_model ,   fr ) \n     protein_st   =   updated_cms . extract ( protein_aids ) \n     # what needs to be done on the protein structure \n     ...", 
            "title": "extract structure once and per frame update coordinates instead of per frame update full system ct and extract structure"
        }, 
        {
            "location": "/paradigms/#try-avoid-unwrap-coordinates-around-periodic-boundary-conditions-yourself", 
            "text": "There are mechanisms in the new trajectory infrastructure to do these unwrapping for you. The relevant analyzer classes are   basic geometric operations  Angle  Distance  Torsion  Vector    CenterOf  Centroid  CoC : center of charge  Com : center of mass     You can even measure geometric quantity between (among) center of mass objects/atoms (see example below), etc.  from   schrodinger.application.desmond.packages   import   analysis  from   schrodinger.application.desmond.packages   import   traj  from   schrodinger.application.desmond.packages   import   topo  # load data  msys_model ,   cms_model   =   topo . read_cms ( FNAME )  tr   =   traj . read_traj ( TRJ_FNAME )  # define analyzers  analyzer1   =   analysis . Com ( msys_model ,   cms_model ,   asl = my_asl )  ana_vector   =   analysis . Vector ( msys_model ,   cms_model ,   1 ,   10 )  analyzer3   =   analysis . ProtLigInter ( msys_model ,   cms_model ,   protein ,   m.n 2 )  s5   =   analysis . Com ( self . msys_model ,   self . cms_model ,   asl = not atom.num 17 )    # this doesn t need to be passed to analysis.analyze  dist_com_atm   =   analysis . Distance ( self . msys_model ,   self . cms_model ,   s5 ,   10 )  # compute result  results   =   analysis . analyze ( tr ,   analyzer1 ,   ana_vector ,   analyzer3 ,   dist_com_atm )   If you have to unwrap yourself, use the  analysis.Pbc  class. Also note that the simulation box may change from frame to frame, e.g. in NPT systems. Thus the  analysis.Pbc  object needs to be updated frame by frame.  Note that the  circular mean algorithm  is used to calculate geometric centers.\nThus it will fail if both of the following conditions apply\n* the selected atoms have a spatial extent comparable to the simulation box\n* the selected atoms do not form a blob-like shape (e.g., dumbbell)", 
            "title": "try avoid unwrap coordinates around periodic boundary conditions yourself"
        }, 
        {
            "location": "/paradigms/#analyze-all-together-instead-of-one-by-one", 
            "text": "If multiple analyzers can share some intermediate calculations, \nthere is a good chance that the new trajectory analysis framework calculates these intermediate results only once.\nThus it is more efficient to call  analysis.analyze  with all analyzers together instead of calling  analysis.analyze  multiple times.  Thus results   =   analysis . analyze ( tr ,   analyzer1 ,   analyzer2 ,   analyzer3 )    is better than result1   =   analysis . analyze ( tr ,   analyzer1 )  result2   =   analysis . analyze ( tr ,   analyzer2 )  result3   =   analysis . analyze ( tr ,   analyzer3 )", 
            "title": "analyze all together instead of one by one"
        }, 
        {
            "location": "/paradigms/#testing", 
            "text": "The new trajectory modules are in the desmond package.\nThus if you are working on a non-desmond repo and uses trajectory stuff, test has to be written in the following way   use  test_marker.require_product('desmond')  lazy import the trajectory handling modules   # Lazy import, in case desmond is not installed  mf   =   None  @pytest.fixture ( scope = module ,   autouse = True )  def   import_my_file (): \n     global   mf \n     import   my_file   as   mf", 
            "title": "testing"
        }, 
        {
            "location": "/correspondence/", 
            "text": "access structure\n\n\nold\n\nimport\n \nschrodinger.trajectory.cmsstructure\n \nas\n \ncmsstructure\n\n\nimport\n \nschrodinger.structutils.analyze\n \nas\n \nanalyze\n\n\n\ncms_st\n \n=\n \ncmsstructure\n.\nread_cms\n(\nmodel_fname\n)\n\n\nfor\n \na\n \nin\n \ncms_st\n.\natom\n:\n\n    \nprint\n(\na\n.\nindex\n)\n\n\nligand_aids\n \n=\n \nanalyze\n.\nevaluate_asl\n(\ncms_st\n,\n \nligand_asl\n)\n\n\n\n\nnew\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nmodel_fname\n)\n\n\nfor\n \na\n \nin\n \ncms_model\n.\natom\n:\n\n    \nprint\n(\na\n.\nindex\n)\n\n\nligand_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nligand_asl\n)\n\n\n\n\n\n\naccess trajectory\n\n\nold\n\nfrom\n \nschrodinger.trajectory.desmondsimulation\n \nimport\n \nChorusSimulation\n\n\nfrom\n \nschrodinger.infra\n \nimport\n \ndesmond\n\n\n\ntr\n \n=\n \ndesmond\n.\ngeneric_trajectory\n(\ntrajectory_directory\n)\n\n\ndt\n \n=\n \ntr\n.\nframe_time\n(\n1\n)\n \n-\n \ntr\n.\nframe_time\n(\n0\n)\n\n\n\ncsim\n \n=\n \nChorusSimulation\n(\ncms_filename\n,\n \ntrajectory_directory\n)\n\n\nfor\n \nframe_index\n \nin\n \nxrange\n(\ncsim\n.\ntotal_frame\n):\n\n    \nfr\n \n=\n \ncsim\n.\ngetFrame\n(\nframe_index\n)\n\n    \nst\n \n=\n \nfr\n.\ngetStructure\n()\n/\npre\n \n|\n \npre\n\n\n\n\n\n\nnew\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nmodel_fname\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\ndt\n \n=\n \ntr\n[\n1\n]\n.\ntime\n \n-\n \ntr\n[\n0\n]\n.\ntime\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nst\n \n=\n \ntopo\n.\nupdate_fsys_ct\n(\ncms_model\n,\n \nfr\n)\n.\nfsys_ct\n\n    \n# you can use st = topo.update_fsys_ct(cms_model, fr) as well\n\n    \n# the properties of cms_model and its fsys_ct are in sync\n\n\n\n\nNote that\n\n\n\n\nalthough there is a correspondence of \nst = fr.getStructure()\n, it is likely not the way to go. See \nthis paradigm\n.\n\n\nthere are two ways to update the \ncms_model\n\n\nupdated_cms\n \n=\n \ntopo\n.\nupdate_fsys_ct\n(\ncms_model\n,\n \nfr\n)\n\n\nupdated_cms\n \n=\n \ntopo\n.\nupdate_cms\n(\ncms_model\n,\n \nfr\n)\n\n\n\n\n\n\n\n\nThe difference is that \nupdate_cms\n not only updates full system ct, but also component cts.", 
            "title": "Correspondence"
        }, 
        {
            "location": "/correspondence/#access-structure", 
            "text": "old import   schrodinger.trajectory.cmsstructure   as   cmsstructure  import   schrodinger.structutils.analyze   as   analyze  cms_st   =   cmsstructure . read_cms ( model_fname )  for   a   in   cms_st . atom : \n     print ( a . index )  ligand_aids   =   analyze . evaluate_asl ( cms_st ,   ligand_asl )  \n\nnew import   schrodinger.application.desmond.packages.topo   as   topo  _ ,   cms_model   =   topo . read_cms ( model_fname )  for   a   in   cms_model . atom : \n     print ( a . index )  ligand_aids   =   cms_model . select_atom ( ligand_asl )", 
            "title": "access structure"
        }, 
        {
            "location": "/correspondence/#access-trajectory", 
            "text": "old from   schrodinger.trajectory.desmondsimulation   import   ChorusSimulation  from   schrodinger.infra   import   desmond  tr   =   desmond . generic_trajectory ( trajectory_directory )  dt   =   tr . frame_time ( 1 )   -   tr . frame_time ( 0 )  csim   =   ChorusSimulation ( cms_filename ,   trajectory_directory )  for   frame_index   in   xrange ( csim . total_frame ): \n     fr   =   csim . getFrame ( frame_index ) \n     st   =   fr . getStructure () / pre   |   pre    new import   schrodinger.application.desmond.packages.traj   as   traj  import   schrodinger.application.desmond.packages.topo   as   topo  _ ,   cms_model   =   topo . read_cms ( model_fname )  tr   =   traj . read_traj ( trajectory_directory )  dt   =   tr [ 1 ] . time   -   tr [ 0 ] . time  for   fr   in   tr : \n     st   =   topo . update_fsys_ct ( cms_model ,   fr ) . fsys_ct \n     # you can use st = topo.update_fsys_ct(cms_model, fr) as well \n     # the properties of cms_model and its fsys_ct are in sync  \n\nNote that   although there is a correspondence of  st = fr.getStructure() , it is likely not the way to go. See  this paradigm .  there are two ways to update the  cms_model  updated_cms   =   topo . update_fsys_ct ( cms_model ,   fr )  updated_cms   =   topo . update_cms ( cms_model ,   fr )     The difference is that  update_cms  not only updates full system ct, but also component cts.", 
            "title": "access trajectory"
        }
    ]
}