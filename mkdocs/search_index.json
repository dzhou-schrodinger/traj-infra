{
    "docs": [
        {
            "location": "/", 
            "text": "highlights\n\n\nCompared to the old trajectory infrastructure, the new one performs better in the following aspects\n\n\n\n\ntracking virtual sites (pseudo atoms)\n\n\nhandling triclinic systems and orthorhombic systems whose primitive cell vectors do not align with the axes\n\n\nunwrapping coordinates around periodic boundary condition (automatically or manually)\n\n\n\n\nIt is also made more robust and faster.\n\n\nmodule changes\n\n\nThe following modules are deprecated\n\nschrodinger\n.\ntrajectory\n\n\nschrodinger\n.\ninfra\n.\ndesmond\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\ndestro\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\nperiodicfix\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\nframesettools\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\ngenerictrajectory\n\n\n\n\n\n\nAnd the replacements are\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ntopo\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ntraj\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ntraj_util\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\nanalysis\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ndestro\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\nstaf\n\n\n\n\n\n\n\n\ntopo: \nCms\n object manipulation, GID tracking/conversion\n\n\ntraj and traj_util: definition of the new \nFrame\n object, trajectory read/write\n\n\nanalysis: definition of various trajectory analyzers (see below)\n\n\ndestro: the maeff class enables low-level mae file IO (try to avoid using it if you can, it bypasses all python-level and swig-level APIs)\n\n\nstaf: abstract base classes for trajectory analyzers\n\n\n\n\nanalyzers in the new trajectory infrastructure\n\n\n\n\nbasic geometric operations\n\n\nAngle\n\n\nDistance\n\n\nPlanarAngle\n\n\nTorsion\n\n\nVector\n\n\n\n\n\n\nCenterOf\n\n\nCentroid\n\n\nCoC\n: center of charge\n\n\nCom\n: center of mass\n\n\n\n\n\n\nDipole\n\n\nGyradius\n: radius of gyration\n\n\nHydrogenBondFinder\n\n\nMassAvgVel\n: mass-averaged velocity\n\n\nMolecularSurfaceArea\n\n\nMomentOfInertia\n\n\nOrderParameter\n\n\nthe following analyzers are inputs to \nOrderParameter\n\n\nAxisDirector\n\n\nDipoleDirector\n\n\nLipidDirector\n\n\nsn1\n\n\nsn2\n\n\nall\n\n\n\n\n\n\nMomentOfInertiaDirector\n\n\nSmartsDirector\n\n\nSystemDipoleDirector\n\n\n\n\n\n\n\n\n\n\nPolarSurfaceArea\n\n\nPosAlign\n: align positions\n\n\nRMSD\n: Root mean square deviation\n\n\nLigandRMSD\n: further includes symmetry consideration\n\n\n\n\n\n\nRMSF\n: Root mean square fluctuation\n\n\nProteinRMSF\n\n\n\n\n\n\nCovarianceMatrix\n\n\n\n\n\n\nPosTrack\n: track positions of selected atoms in a trajectory\n\n\nProtLigInter\n: Protein-ligand interactions\n\n\nHydrophobicInter\n, `_HydrophobicInter\n\n\nMetalInter\n\n\nProtLigHbondInter\n\n\nProtLigPiInter\n\n\nProtLigPolarInter\n, \n_ProtLigPolarInter\n\n\nWaterBridges\n\n\nWatLigFragDistance\n, \n_WatLigFragDistance\n\n\n\n\n\n\nProtProtInter\n: Protein-protein interactions\n\n\nProtProtHbondInter\n\n\nProtProtPiInter\n\n\nProtProtSaltBridges\n\n\n\n\n\n\nRdf\n: Radial distribution function\n\n\nRamachandran\n\n\nSecondaryStructure\n\n\nSaltBridgeFinder\n\n\nSolventAccessibleSurfaceArea\n\n\nSolventAccessibleSurfaceAreaByResidue\n\n\nVolumeMapper\n\n\n\n\nIn case you want to write customerized analyzer, I can share another document with you.", 
            "title": "Home"
        }, 
        {
            "location": "/#highlights", 
            "text": "Compared to the old trajectory infrastructure, the new one performs better in the following aspects   tracking virtual sites (pseudo atoms)  handling triclinic systems and orthorhombic systems whose primitive cell vectors do not align with the axes  unwrapping coordinates around periodic boundary condition (automatically or manually)   It is also made more robust and faster.", 
            "title": "highlights"
        }, 
        {
            "location": "/#module-changes", 
            "text": "The following modules are deprecated schrodinger . trajectory  schrodinger . infra . desmond  schrodinger . application . desmond . destro  schrodinger . application . desmond . periodicfix  schrodinger . application . desmond . framesettools  schrodinger . application . desmond . generictrajectory    And the replacements are schrodinger . application . desmond . packages . topo  schrodinger . application . desmond . packages . traj  schrodinger . application . desmond . packages . traj_util  schrodinger . application . desmond . packages . analysis  schrodinger . application . desmond . packages . destro  schrodinger . application . desmond . packages . staf     topo:  Cms  object manipulation, GID tracking/conversion  traj and traj_util: definition of the new  Frame  object, trajectory read/write  analysis: definition of various trajectory analyzers (see below)  destro: the maeff class enables low-level mae file IO (try to avoid using it if you can, it bypasses all python-level and swig-level APIs)  staf: abstract base classes for trajectory analyzers", 
            "title": "module changes"
        }, 
        {
            "location": "/#analyzers-in-the-new-trajectory-infrastructure", 
            "text": "basic geometric operations  Angle  Distance  PlanarAngle  Torsion  Vector    CenterOf  Centroid  CoC : center of charge  Com : center of mass    Dipole  Gyradius : radius of gyration  HydrogenBondFinder  MassAvgVel : mass-averaged velocity  MolecularSurfaceArea  MomentOfInertia  OrderParameter  the following analyzers are inputs to  OrderParameter  AxisDirector  DipoleDirector  LipidDirector  sn1  sn2  all    MomentOfInertiaDirector  SmartsDirector  SystemDipoleDirector      PolarSurfaceArea  PosAlign : align positions  RMSD : Root mean square deviation  LigandRMSD : further includes symmetry consideration    RMSF : Root mean square fluctuation  ProteinRMSF    CovarianceMatrix    PosTrack : track positions of selected atoms in a trajectory  ProtLigInter : Protein-ligand interactions  HydrophobicInter , `_HydrophobicInter  MetalInter  ProtLigHbondInter  ProtLigPiInter  ProtLigPolarInter ,  _ProtLigPolarInter  WaterBridges  WatLigFragDistance ,  _WatLigFragDistance    ProtProtInter : Protein-protein interactions  ProtProtHbondInter  ProtProtPiInter  ProtProtSaltBridges    Rdf : Radial distribution function  Ramachandran  SecondaryStructure  SaltBridgeFinder  SolventAccessibleSurfaceArea  SolventAccessibleSurfaceAreaByResidue  VolumeMapper   In case you want to write customerized analyzer, I can share another document with you.", 
            "title": "analyzers in the new trajectory infrastructure"
        }, 
        {
            "location": "/fundamentals/", 
            "text": "introduction\n\n\nRoughly speaking, here are the correspondences between the old and new infrastructures:\n\n\n\n\n\n\n\n\nold\n\n\nnew\n\n\n\n\n\n\n\n\n\n\nDesmondSimulation\n or \nChorusSimulation\n object\n\n\nCms\n object and trajectory object\n\n\n\n\n\n\n_DesmondFrame\n object\n\n\ntraj.Frame\n object\n\n\n\n\n\n\nschrodinger.infra.desmond.Trajectory\n or \nframesettools.Frameset\n\n\npython list of \ntraj.Frame\n objects\n\n\n\n\n\n\n\n\nNote that\n\n\n\n\nThe new frame object is different from the old one.\n\n\nThe new trajectory object is simply a python list of \ntraj.Frame\n objects\n\n\nThe following properties and function calls are guaranteed for a frame object\n\n\nfr.natoms\n: pseudo-atoms are included\n\n\nfr.pos()\n, \nfr.pos(gids)\n, \nfr.pos(gid)\n\n\nfr.time\n\n\nfr.box\n\n\n\n\n\n\nThe function call \nfr.vel()\n is not guaranteed. XTC data will not have this, DTR data may not have it either.\n\n\nIf the data is DTR, you may be able to pull out more (private) information such as \nfr._frame().temperature\n. Use with your own risk.\n\n\n\n\nminimum examples\n\n\nThe CMS files contain structures for MD related workflows.\nThe first structure is the full system CT used for Maestro display.\nThe rest are component CTs.\n\n\nThere are three ways to read a CMS file\n\n\nimport\n \nschrodinger.structure\n \nas\n \nstructure\n\n\nst_reader\n \n=\n \nstructure\n.\nStructureReader\n(\nexample-out.cms\n)\n\n\ncts\n \n=\n \nlist\n(\nst_reader\n)\n\n\n\n\n\n\nfrom\n \nschrodinger.application.desmond.cms\n \nimport\n \nCms\n\n\ncms_model\n \n=\n \nCms\n(\nexample-out.cms\n)\n\n\n\n\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nexample-out.cms\n)\n\n\n\n\n\n\nThe loading speed decreases for the latter methods. But more information becomes available in the latter methods as well.\nFor trajectory analysis, the third method is the preferred one as often times an \nmsys_model\n is needed for trajectory analysis.\n\n\nTo read a trajectory\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\n\n\n\n\nHere \ntr\n is simply a python list of trajectory \nFrame\n objects.\n\n\nTo do some analysis using existing analyzers\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \nanalysis\n,\n \ntraj\n,\n \ntopo\n\n\n\n# load data\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nFNAME\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\nTRJ_FNAME\n)\n\n\n\n# define analyzers\n\n\nanalyzer1\n \n=\n \nanalysis\n.\nCom\n(\nmsys_model\n,\n \ncms_model\n,\n \nasl\n=\nm.n 1\n)\n\n\nanalyzer2\n \n=\n \nanalysis\n.\nProtLigInter\n(\nmsys_model\n,\n \ncms_model\n,\n \nprotein\n,\n \nm.n 2\n)\n\n\n\n# compute result\n\n\nresults\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n,\n \nanalyzer2\n,\n \n)\n\n\n\n\n\n\nThe \nresults\n is a list of the analyzers' output.\nIn the above example, \nresults\n is a list of 2 items, corresponding to the output of the two analyzers.\n\n\nThe analyzers' output format varies.\nTypically, the output is a list of frame-wise results.\n\n\natom AIDs and atom GIDs\n\n\nIn MD simulation, there are two types of atoms\n\n\n\n\nphysical atoms\n\n\npseudo atoms (virtual sites): They have fractional charge and 0 mass. They are used to model forcefield better.\n\n\n\n\nIn Maestro, the pseudo atoms are not displayed.\n\n\nTo keep track of the atoms, there are two types of IDs\n\n\n\n\nAID stands for Atom ID, defined as the atom index in the full system ct (it is the same as \ncms_model.atom.index\n). It starts with 1.\n\n\nGID stands for Global ID, defined as the particle index in the Desmond internal particle array. It starts with 0.\n\n\n\n\nNote that\n\n\n\n\nPseudo atoms do not have AID.\n\n\nIf no pseudo atoms are present, then \nAID = GID + 1\n. In general, one cannot rely on this.\n\n\n\n\nTo access a particle's coordinate in the trajectory (i.e., the \ntraj.Frame\n object), you have to use GID.\nWe have functions to map AID to GID in the \ntopo\n module. For example,\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_filename\n)\n\n\nprotein_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nprotein_asl\n)\n\n\nprotein_gids\n \n=\n \ntopo\n.\naids2gids\n(\ncms_model\n,\n \nprotein_aids\n,\n\n                              \ninclude_pseudoatoms\n=\nFalse\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nfr\n.\npos\n(\nprotein_gids\n)\n\n    \nfr\n.\nvel\n(\nprotein_gids\n)\n\n\n\n\nBoth \ntraj.Frame.pos()\n and \ntraj.Frame.vel()\n return Nx3 numpy arrays,\nWithout argument input, they return the positions or velocities of all atoms.\nWith GIDs input, the order of the output follows the order of the GID input.\nFor example \n\n\nIn [8]: fr0.pos([2,3])\nOut[8]:\narray([[-4.77608204,  3.04622388,  1.31021202],\n       [-5.66208792,  1.88501239,  0.96774006]], dtype=float32)\n\nIn [9]: fr0.pos([3,2])\nOut[9]:\narray([[-5.66208792,  1.88501239,  0.96774006],\n       [-4.77608204,  3.04622388,  1.31021202]], dtype=float32)\n\n\n\n\n\nOne can use the GID directly to get the single atom coordinate too\n\nIn [7]: fr0.pos(0)\nOut[7]: array([-0.76461941, -2.64227247, -0.62481445], dtype=float32)\n\n\n\n\n\nNote that\n\n\n\n\nvel()\n may not exist. Default MD simulation does not save velocities, also the XTC format trajectories do not contain velocities.\n\n\nIf you get positions this way, then you need to worry about unwrapping around PBC yourself. If you don't want to unwrap yourself, try use the existing mechanisms in the infrastructure. See \nthis paradigm\n.\n\n\n\n\nASL and SMARTS evaluations only return AIDs. In other words, they only select physical atoms.\nThere are two helper functions in the topo module to select GIDS:\n\ntopo.asl2gids()\ntopo.aids2gids()", 
            "title": "Fundamentals"
        }, 
        {
            "location": "/fundamentals/#introduction", 
            "text": "Roughly speaking, here are the correspondences between the old and new infrastructures:     old  new      DesmondSimulation  or  ChorusSimulation  object  Cms  object and trajectory object    _DesmondFrame  object  traj.Frame  object    schrodinger.infra.desmond.Trajectory  or  framesettools.Frameset  python list of  traj.Frame  objects     Note that   The new frame object is different from the old one.  The new trajectory object is simply a python list of  traj.Frame  objects  The following properties and function calls are guaranteed for a frame object  fr.natoms : pseudo-atoms are included  fr.pos() ,  fr.pos(gids) ,  fr.pos(gid)  fr.time  fr.box    The function call  fr.vel()  is not guaranteed. XTC data will not have this, DTR data may not have it either.  If the data is DTR, you may be able to pull out more (private) information such as  fr._frame().temperature . Use with your own risk.", 
            "title": "introduction"
        }, 
        {
            "location": "/fundamentals/#minimum-examples", 
            "text": "The CMS files contain structures for MD related workflows.\nThe first structure is the full system CT used for Maestro display.\nThe rest are component CTs.  There are three ways to read a CMS file  import   schrodinger.structure   as   structure  st_reader   =   structure . StructureReader ( example-out.cms )  cts   =   list ( st_reader )   from   schrodinger.application.desmond.cms   import   Cms  cms_model   =   Cms ( example-out.cms )   import   schrodinger.application.desmond.packages.topo   as   topo  msys_model ,   cms_model   =   topo . read_cms ( example-out.cms )   The loading speed decreases for the latter methods. But more information becomes available in the latter methods as well.\nFor trajectory analysis, the third method is the preferred one as often times an  msys_model  is needed for trajectory analysis.  To read a trajectory import   schrodinger.application.desmond.packages.traj   as   traj  tr   =   traj . read_traj ( trajectory_directory )    Here  tr  is simply a python list of trajectory  Frame  objects.  To do some analysis using existing analyzers  from   schrodinger.application.desmond.packages   import   analysis ,   traj ,   topo  # load data  msys_model ,   cms_model   =   topo . read_cms ( FNAME )  tr   =   traj . read_traj ( TRJ_FNAME )  # define analyzers  analyzer1   =   analysis . Com ( msys_model ,   cms_model ,   asl = m.n 1 )  analyzer2   =   analysis . ProtLigInter ( msys_model ,   cms_model ,   protein ,   m.n 2 )  # compute result  results   =   analysis . analyze ( tr ,   analyzer1 ,   analyzer2 ,   )   The  results  is a list of the analyzers' output.\nIn the above example,  results  is a list of 2 items, corresponding to the output of the two analyzers.  The analyzers' output format varies.\nTypically, the output is a list of frame-wise results.", 
            "title": "minimum examples"
        }, 
        {
            "location": "/fundamentals/#atom-aids-and-atom-gids", 
            "text": "In MD simulation, there are two types of atoms   physical atoms  pseudo atoms (virtual sites): They have fractional charge and 0 mass. They are used to model forcefield better.   In Maestro, the pseudo atoms are not displayed.  To keep track of the atoms, there are two types of IDs   AID stands for Atom ID, defined as the atom index in the full system ct (it is the same as  cms_model.atom.index ). It starts with 1.  GID stands for Global ID, defined as the particle index in the Desmond internal particle array. It starts with 0.   Note that   Pseudo atoms do not have AID.  If no pseudo atoms are present, then  AID = GID + 1 . In general, one cannot rely on this.   To access a particle's coordinate in the trajectory (i.e., the  traj.Frame  object), you have to use GID.\nWe have functions to map AID to GID in the  topo  module. For example,  import   schrodinger.application.desmond.packages.topo   as   topo  import   schrodinger.application.desmond.packages.traj   as   traj  _ ,   cms_model   =   topo . read_cms ( cms_filename )  protein_aids   =   cms_model . select_atom ( protein_asl )  protein_gids   =   topo . aids2gids ( cms_model ,   protein_aids , \n                               include_pseudoatoms = False )  tr   =   traj . read_traj ( trajectory_directory )  for   fr   in   tr : \n     fr . pos ( protein_gids ) \n     fr . vel ( protein_gids )  \n\nBoth  traj.Frame.pos()  and  traj.Frame.vel()  return Nx3 numpy arrays,\nWithout argument input, they return the positions or velocities of all atoms.\nWith GIDs input, the order of the output follows the order of the GID input.\nFor example   In [8]: fr0.pos([2,3])\nOut[8]:\narray([[-4.77608204,  3.04622388,  1.31021202],\n       [-5.66208792,  1.88501239,  0.96774006]], dtype=float32)\n\nIn [9]: fr0.pos([3,2])\nOut[9]:\narray([[-5.66208792,  1.88501239,  0.96774006],\n       [-4.77608204,  3.04622388,  1.31021202]], dtype=float32)  One can use the GID directly to get the single atom coordinate too In [7]: fr0.pos(0)\nOut[7]: array([-0.76461941, -2.64227247, -0.62481445], dtype=float32)   Note that   vel()  may not exist. Default MD simulation does not save velocities, also the XTC format trajectories do not contain velocities.  If you get positions this way, then you need to worry about unwrapping around PBC yourself. If you don't want to unwrap yourself, try use the existing mechanisms in the infrastructure. See  this paradigm .   ASL and SMARTS evaluations only return AIDs. In other words, they only select physical atoms.\nThere are two helper functions in the topo module to select GIDS: topo.asl2gids()\ntopo.aids2gids()", 
            "title": "atom AIDs and atom GIDs"
        }, 
        {
            "location": "/paradigms/", 
            "text": "load both cms file and trajectory in case trajectory path is not specified\n\n\nIdeally, the user should specify the paths for both the cms file and the trajectory file.\nIn case the trajectory path is missing, one should make sure\n\n\n\n\nthe cms file and trajectory file are in the same directory\n\n\nthe \ns_chorus_trajectory_file\n property in the cms file points to the relative path of the trajectory file\n\n\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nargs\n.\ncms_file\n)\n\n\ntrj_path\n \n=\n \ntopo\n.\nfind_traj_path\n(\ncms_model\n,\n \nos\n.\npath\n.\ndirname\n(\nargs\n.\ncms_file\n))\n\n\nif\n \ntrj_path\n \nis\n \nNone\n:\n\n    \nparser\n.\nerror\n(\nCould not locate a trajectory directory for given CMS file\n)\n\n\ntry\n:\n\n    \ntrj\n \n=\n \ntraj\n.\nread_traj\n(\ntrj_path\n)\n\n\nexcept\n \nException\n \nas\n \ne\n:\n\n    \nparser\n.\nerror\n(\nCannot load trajectory file: \n%s\n \n%\n \ne\n)\n\n\n\n\n\n\nFor GUI, often times one only needs to get the trajectory path from the cms file path, then the following code can be used\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\n\ntrj_path\n \n=\n \ntopo\n.\nfind_traj_path_from_cms_path\n(\ncms_path\n)\n\n\n\n\n\n\nNote one should still check whether \ntrj_path\n is \nNone\n and do \ntry except\n for \ntraj.read_traj\n.\n\n\nAnother useful helper function to load both \ncms_model\n and trajectory is \nread_cms_and_traj\n\n\nfrom schrodinger.application.desmond.packages import traj_util\n\ntry:\n    _, cms_model, trj = traj_util.read_cms_and_traj(cmsfile)\nexcept traj_util.TrajectoryUnreadableError as err:\n    print(err)\n    sys.exit(1)\n\n\n\n\n\nextract structure once and per frame update coordinates instead of per frame update full system ct and extract structure\n\n\nNote that although one can get the full system ct per frame in new trajectory infrastructure, it is likely the inefficient approach.\nIn most cases, the user does not need to track the full system ct over the frames.\nInstead, only specific group of atoms or molecules needs to be tracked over the frames.\nIn these situations, it is more efficient to\n\n\n\n\nextract the atoms or molecules into a structure once\n\n\nkeep updating (or maybe only read) the coordinates of the selected atoms or molecules frame by frame\n\n\n\n\nIf the analysis is fully geometric, then the structure extraction can be avoided as well.\n\n\nHere is an example\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_filename\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\nprotein_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nprotein_asl\n)\n\n\nprotein_gids\n \n=\n \ntopo\n.\naids2gids\n(\ncms_model\n,\n \nprotein_aids\n,\n\n                              \ninclude_pseudoatoms\n=\nFalse\n)\n\n\nprotein_st\n \n=\n \ncms_model\n.\nextract\n(\nprotein_aids\n)\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nprotein_st\n.\nsetXYZ\n(\nfr\n.\npos\n(\nprotein_gids\n))\n\n    \n# what needs to be done on the protein structure\n\n    \n...\n\n\n\n\n\n\nThis is better than\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_filename\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\nprotein_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nprotein_asl\n)\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nupdated_cms\n \n=\n \ntopo\n.\nupdate_fsys_ct\n(\ncms_model\n,\n \nfr\n)\n\n    \nprotein_st\n \n=\n \nupdated_cms\n.\nextract\n(\nprotein_aids\n)\n\n    \n# what needs to be done on the protein structure\n\n    \n...\n\n\n\n\n\n\ntry avoid unwrap coordinates around periodic boundary conditions yourself\n\n\nThere are mechanisms in the new trajectory infrastructure to do these unwrapping for you. The relevant analyzer classes are\n\n\n\n\nbasic geometric operations\n\n\nAngle\n\n\nDistance\n\n\nTorsion\n\n\nVector\n\n\n\n\n\n\nCenterOf\n\n\nCentroid\n\n\nCoC\n: center of charge\n\n\nCom\n: center of mass\n\n\n\n\n\n\n\n\nYou can even measure geometric quantity between (among) center of mass objects/atoms (see example below), etc.\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \nanalysis\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \ntraj\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \ntopo\n\n\n\n# load data\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nFNAME\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\nTRJ_FNAME\n)\n\n\n\n# define analyzers\n\n\nanalyzer1\n \n=\n \nanalysis\n.\nCom\n(\nmsys_model\n,\n \ncms_model\n,\n \nasl\n=\nmy_asl\n)\n\n\nana_vector\n \n=\n \nanalysis\n.\nVector\n(\nmsys_model\n,\n \ncms_model\n,\n \n1\n,\n \n10\n)\n\n\nanalyzer3\n \n=\n \nanalysis\n.\nProtLigInter\n(\nmsys_model\n,\n \ncms_model\n,\n \nprotein\n,\n \nm.n 2\n)\n\n\ns5\n \n=\n \nanalysis\n.\nCom\n(\nself\n.\nmsys_model\n,\n \nself\n.\ncms_model\n,\n \nasl\n=\nnot atom.num 17\n)\n  \n# this doesn\nt need to be passed to analysis.analyze\n\n\ndist_com_atm\n \n=\n \nanalysis\n.\nDistance\n(\nself\n.\nmsys_model\n,\n \nself\n.\ncms_model\n,\n \ns5\n,\n \n10\n)\n\n\n\n# compute result\n\n\nresults\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n,\n \nana_vector\n,\n \nanalyzer3\n,\n \ndist_com_atm\n)\n\n\n\n\n\n\nIf you have to unwrap yourself, use the \nanalysis.Pbc\n class. Also note that the simulation box may change from frame to frame, e.g. in NPT systems. Thus the \nanalysis.Pbc\n object needs to be updated frame by frame.\n\n\nNote that the \ncircular mean algorithm\n is used to calculate geometric centers.\nThus it will fail if both of the following conditions apply\n* the selected atoms have a spatial extent comparable to the simulation box\n* the selected atoms do not form a blob-like shape (e.g., dumbbell)\n\n\nanalyze all together instead of one by one\n\n\nIf multiple analyzers can share some intermediate calculations, \nthere is a good chance that the new trajectory analysis framework calculates these intermediate results only once.\nThus it is more efficient to call \nanalysis.analyze\n with all analyzers together instead of calling \nanalysis.analyze\n multiple times.\n\n\nThus\n\nresults\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n,\n \nanalyzer2\n,\n \nanalyzer3\n)\n\n\n\n\n\n\nis better than\n\nresult1\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n)\n\n\nresult2\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer2\n)\n\n\nresult3\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer3\n)\n\n\n\n\n\n\ntesting\n\n\nThe new trajectory modules are in the desmond package.\nThus if you are working on a non-desmond repo and uses trajectory stuff, test has to be written in the following way\n\n\n\n\nuse \ntest_marker.require_product('desmond')\n\n\nlazy import the trajectory handling modules\n\n\n\n\nimport\n \npytest\n\n\n\n# Lazy import, in case desmond is not installed\n\n\nmf\n \n=\n \nNone\n\n\n\n@pytest.fixture\n(\nscope\n=\nmodule\n,\n \nautouse\n=\nTrue\n)\n\n\ndef\n \nimport_my_file\n():\n\n    \nglobal\n \nmf\n\n    \nimport\n \nmy_file\n \nas\n \nmf", 
            "title": "Paradigms"
        }, 
        {
            "location": "/paradigms/#load-both-cms-file-and-trajectory-in-case-trajectory-path-is-not-specified", 
            "text": "Ideally, the user should specify the paths for both the cms file and the trajectory file.\nIn case the trajectory path is missing, one should make sure   the cms file and trajectory file are in the same directory  the  s_chorus_trajectory_file  property in the cms file points to the relative path of the trajectory file   import   schrodinger.application.desmond.packages.topo   as   topo  import   schrodinger.application.desmond.packages.traj   as   traj  msys_model ,   cms_model   =   topo . read_cms ( args . cms_file )  trj_path   =   topo . find_traj_path ( cms_model ,   os . path . dirname ( args . cms_file ))  if   trj_path   is   None : \n     parser . error ( Could not locate a trajectory directory for given CMS file )  try : \n     trj   =   traj . read_traj ( trj_path )  except   Exception   as   e : \n     parser . error ( Cannot load trajectory file:  %s   %   e )   For GUI, often times one only needs to get the trajectory path from the cms file path, then the following code can be used  import   schrodinger.application.desmond.packages.topo   as   topo  trj_path   =   topo . find_traj_path_from_cms_path ( cms_path )   Note one should still check whether  trj_path  is  None  and do  try except  for  traj.read_traj .  Another useful helper function to load both  cms_model  and trajectory is  read_cms_and_traj  from schrodinger.application.desmond.packages import traj_util\n\ntry:\n    _, cms_model, trj = traj_util.read_cms_and_traj(cmsfile)\nexcept traj_util.TrajectoryUnreadableError as err:\n    print(err)\n    sys.exit(1)", 
            "title": "load both cms file and trajectory in case trajectory path is not specified"
        }, 
        {
            "location": "/paradigms/#extract-structure-once-and-per-frame-update-coordinates-instead-of-per-frame-update-full-system-ct-and-extract-structure", 
            "text": "Note that although one can get the full system ct per frame in new trajectory infrastructure, it is likely the inefficient approach.\nIn most cases, the user does not need to track the full system ct over the frames.\nInstead, only specific group of atoms or molecules needs to be tracked over the frames.\nIn these situations, it is more efficient to   extract the atoms or molecules into a structure once  keep updating (or maybe only read) the coordinates of the selected atoms or molecules frame by frame   If the analysis is fully geometric, then the structure extraction can be avoided as well.  Here is an example  import   schrodinger.application.desmond.packages.topo   as   topo  import   schrodinger.application.desmond.packages.traj   as   traj  _ ,   cms_model   =   topo . read_cms ( cms_filename )  tr   =   traj . read_traj ( trajectory_directory )  protein_aids   =   cms_model . select_atom ( protein_asl )  protein_gids   =   topo . aids2gids ( cms_model ,   protein_aids , \n                               include_pseudoatoms = False )  protein_st   =   cms_model . extract ( protein_aids )  for   fr   in   tr : \n     protein_st . setXYZ ( fr . pos ( protein_gids )) \n     # what needs to be done on the protein structure \n     ...   This is better than  _ ,   cms_model   =   topo . read_cms ( cms_filename )  tr   =   traj . read_traj ( trajectory_directory )  protein_aids   =   cms_model . select_atom ( protein_asl )  for   fr   in   tr : \n     updated_cms   =   topo . update_fsys_ct ( cms_model ,   fr ) \n     protein_st   =   updated_cms . extract ( protein_aids ) \n     # what needs to be done on the protein structure \n     ...", 
            "title": "extract structure once and per frame update coordinates instead of per frame update full system ct and extract structure"
        }, 
        {
            "location": "/paradigms/#try-avoid-unwrap-coordinates-around-periodic-boundary-conditions-yourself", 
            "text": "There are mechanisms in the new trajectory infrastructure to do these unwrapping for you. The relevant analyzer classes are   basic geometric operations  Angle  Distance  Torsion  Vector    CenterOf  Centroid  CoC : center of charge  Com : center of mass     You can even measure geometric quantity between (among) center of mass objects/atoms (see example below), etc.  from   schrodinger.application.desmond.packages   import   analysis  from   schrodinger.application.desmond.packages   import   traj  from   schrodinger.application.desmond.packages   import   topo  # load data  msys_model ,   cms_model   =   topo . read_cms ( FNAME )  tr   =   traj . read_traj ( TRJ_FNAME )  # define analyzers  analyzer1   =   analysis . Com ( msys_model ,   cms_model ,   asl = my_asl )  ana_vector   =   analysis . Vector ( msys_model ,   cms_model ,   1 ,   10 )  analyzer3   =   analysis . ProtLigInter ( msys_model ,   cms_model ,   protein ,   m.n 2 )  s5   =   analysis . Com ( self . msys_model ,   self . cms_model ,   asl = not atom.num 17 )    # this doesn t need to be passed to analysis.analyze  dist_com_atm   =   analysis . Distance ( self . msys_model ,   self . cms_model ,   s5 ,   10 )  # compute result  results   =   analysis . analyze ( tr ,   analyzer1 ,   ana_vector ,   analyzer3 ,   dist_com_atm )   If you have to unwrap yourself, use the  analysis.Pbc  class. Also note that the simulation box may change from frame to frame, e.g. in NPT systems. Thus the  analysis.Pbc  object needs to be updated frame by frame.  Note that the  circular mean algorithm  is used to calculate geometric centers.\nThus it will fail if both of the following conditions apply\n* the selected atoms have a spatial extent comparable to the simulation box\n* the selected atoms do not form a blob-like shape (e.g., dumbbell)", 
            "title": "try avoid unwrap coordinates around periodic boundary conditions yourself"
        }, 
        {
            "location": "/paradigms/#analyze-all-together-instead-of-one-by-one", 
            "text": "If multiple analyzers can share some intermediate calculations, \nthere is a good chance that the new trajectory analysis framework calculates these intermediate results only once.\nThus it is more efficient to call  analysis.analyze  with all analyzers together instead of calling  analysis.analyze  multiple times.  Thus results   =   analysis . analyze ( tr ,   analyzer1 ,   analyzer2 ,   analyzer3 )    is better than result1   =   analysis . analyze ( tr ,   analyzer1 )  result2   =   analysis . analyze ( tr ,   analyzer2 )  result3   =   analysis . analyze ( tr ,   analyzer3 )", 
            "title": "analyze all together instead of one by one"
        }, 
        {
            "location": "/paradigms/#testing", 
            "text": "The new trajectory modules are in the desmond package.\nThus if you are working on a non-desmond repo and uses trajectory stuff, test has to be written in the following way   use  test_marker.require_product('desmond')  lazy import the trajectory handling modules   import   pytest  # Lazy import, in case desmond is not installed  mf   =   None  @pytest.fixture ( scope = module ,   autouse = True )  def   import_my_file (): \n     global   mf \n     import   my_file   as   mf", 
            "title": "testing"
        }, 
        {
            "location": "/correspondence/", 
            "text": "access structure\n\n\nold\n\nimport\n \nschrodinger.trajectory.cmsstructure\n \nas\n \ncmsstructure\n\n\nimport\n \nschrodinger.structutils.analyze\n \nas\n \nanalyze\n\n\n\ncms_st\n \n=\n \ncmsstructure\n.\nread_cms\n(\nmodel_fname\n)\n\n\nfor\n \na\n \nin\n \ncms_st\n.\natom\n:\n\n    \nprint\n(\na\n.\nindex\n)\n\n\nligand_aids\n \n=\n \nanalyze\n.\nevaluate_asl\n(\ncms_st\n,\n \nligand_asl\n)\n\n\n\n\nnew\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nmodel_fname\n)\n\n\nfor\n \na\n \nin\n \ncms_model\n.\natom\n:\n\n    \nprint\n(\na\n.\nindex\n)\n\n\nligand_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nligand_asl\n)\n\n\n\n\n\n\nNote that \nanalyze.evaluate_asl\n does not respect PBC whereas \ncms_model.select_atom\n does.\n\n\naccess trajectory\n\n\nold\n\nfrom\n \nschrodinger.trajectory.desmondsimulation\n \nimport\n \nChorusSimulation\n\n\nfrom\n \nschrodinger.infra\n \nimport\n \ndesmond\n\n\n\ntr\n \n=\n \ndesmond\n.\ngeneric_trajectory\n(\ntrajectory_directory\n)\n\n\ndt\n \n=\n \ntr\n.\nframe_time\n(\n1\n)\n \n-\n \ntr\n.\nframe_time\n(\n0\n)\n\n\n\ncsim\n \n=\n \nChorusSimulation\n(\ncms_filename\n,\n \ntrajectory_directory\n)\n\n\nfor\n \nframe_index\n \nin\n \nxrange\n(\ncsim\n.\ntotal_frame\n):\n\n    \nfr\n \n=\n \ncsim\n.\ngetFrame\n(\nframe_index\n)\n\n    \nst\n \n=\n \nfr\n.\ngetStructure\n()\n\n\n\n\n\n\nnew\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nmodel_fname\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\ndt\n \n=\n \ntr\n[\n1\n]\n.\ntime\n \n-\n \ntr\n[\n0\n]\n.\ntime\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nst\n \n=\n \ntopo\n.\nupdate_fsys_ct\n(\ncms_model\n,\n \nfr\n)\n.\nfsys_ct\n\n    \n# you can use st = topo.update_fsys_ct(cms_model, fr) as well\n\n    \n# since the properties of cms_model and its fsys_ct are in sync\n\n\n\n\nNote that\n\n\n\n\nalthough there is a correspondence of \nst = fr.getStructure()\n, it is likely not the way to go. See \nthis paradigm\n.\n\n\nthere are two ways to update the \ncms_model\n\n\nupdated_cms\n \n=\n \ntopo\n.\nupdate_fsys_ct\n(\ncms_model\n,\n \nfr\n)\n\n\nupdated_cms\n \n=\n \ntopo\n.\nupdate_cms\n(\ncms_model\n,\n \nfr\n)\n\n\n\n\n\n\n\n\nThe difference is that \nupdate_cms\n not only updates full system ct, but also component cts.", 
            "title": "Correspondence"
        }, 
        {
            "location": "/correspondence/#access-structure", 
            "text": "old import   schrodinger.trajectory.cmsstructure   as   cmsstructure  import   schrodinger.structutils.analyze   as   analyze  cms_st   =   cmsstructure . read_cms ( model_fname )  for   a   in   cms_st . atom : \n     print ( a . index )  ligand_aids   =   analyze . evaluate_asl ( cms_st ,   ligand_asl )  \n\nnew import   schrodinger.application.desmond.packages.topo   as   topo  _ ,   cms_model   =   topo . read_cms ( model_fname )  for   a   in   cms_model . atom : \n     print ( a . index )  ligand_aids   =   cms_model . select_atom ( ligand_asl )    Note that  analyze.evaluate_asl  does not respect PBC whereas  cms_model.select_atom  does.", 
            "title": "access structure"
        }, 
        {
            "location": "/correspondence/#access-trajectory", 
            "text": "old from   schrodinger.trajectory.desmondsimulation   import   ChorusSimulation  from   schrodinger.infra   import   desmond  tr   =   desmond . generic_trajectory ( trajectory_directory )  dt   =   tr . frame_time ( 1 )   -   tr . frame_time ( 0 )  csim   =   ChorusSimulation ( cms_filename ,   trajectory_directory )  for   frame_index   in   xrange ( csim . total_frame ): \n     fr   =   csim . getFrame ( frame_index ) \n     st   =   fr . getStructure ()    new import   schrodinger.application.desmond.packages.traj   as   traj  import   schrodinger.application.desmond.packages.topo   as   topo  _ ,   cms_model   =   topo . read_cms ( model_fname )  tr   =   traj . read_traj ( trajectory_directory )  dt   =   tr [ 1 ] . time   -   tr [ 0 ] . time  for   fr   in   tr : \n     st   =   topo . update_fsys_ct ( cms_model ,   fr ) . fsys_ct \n     # you can use st = topo.update_fsys_ct(cms_model, fr) as well \n     # since the properties of cms_model and its fsys_ct are in sync  \n\nNote that   although there is a correspondence of  st = fr.getStructure() , it is likely not the way to go. See  this paradigm .  there are two ways to update the  cms_model  updated_cms   =   topo . update_fsys_ct ( cms_model ,   fr )  updated_cms   =   topo . update_cms ( cms_model ,   fr )     The difference is that  update_cms  not only updates full system ct, but also component cts.", 
            "title": "access trajectory"
        }, 
        {
            "location": "/custom-analyzer/", 
            "text": "overview\n\n\nThis section is for developers who want to write customized trajectory analyzers.\nIt can be skipped if you are satisfied as a user of the existing analyzers.\n\n\nThe main reason to write customized analyzer is code decoupling.\n\n\nAs an introductory example, let's filter a trajectory according to a user\nselected distance cutoff between two atoms.\n\n\n# file loading is omitted \n\n\ndist_ana\n \n=\n \nanalysis\n.\nDistance\n(\nmsys_model\n,\n \ncms_model\n,\n \n1\n,\n \n50\n)\n  \n# atom 1 and 50 are chosen\n\n\ndistances\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \ndist_ana\n)\n\n\n\nout_tr\n \n=\n \n[]\n\n\nfor\n \nfr\n,\n \nd\n \nin\n \nzip\n(\ntr\n,\n \ndistances\n):\n\n    \nif\n \nd\n \n \n4.0\n:\n  \n# 4.0 is the chosen cutoff\n\n        \nout_tr\n.\nappend\n(\nfr\n)\n\n\n\n\n\n\nThe following class is an example of customized analyzer for the same task,\n\n\nclass\n \nSpliter\n(\nstaf\n.\nGeomAnalyzerBase\n):\n\n    \ndef\n \n__init__\n(\nself\n,\n \nmsys_model\n,\n \ncms_model\n,\n \natom1\n,\n \natom2\n,\n \ncutoff\n=\n1\n):\n\n        \nself\n.\ngids\n \n=\n \ntopo\n.\naids2gids\n([\natom1\n,\n \natom2\n],\n \ninclude_pseudoatoms\n=\nFalse\n)\n\n\n    \ndef\n \n_precalc\n(\nself\n,\n \ncalc\n):\n\n        \ncalc\n.\naddDistance\n(\nself\n.\ngids\n[\n0\n],\n \nself\n.\ngids\n[\n1\n])\n\n\n    \ndef\n \n_postcalc\n(\nself\n,\n \ncalc\n,\n \npbc\n,\n \nfr\n):\n\n        \nd\n \n=\n \ncalc\n.\ngetDistance\n(\nself\n.\ngids\n[\n0\n],\n \nself\n.\ngids\n[\n1\n])\n\n        \nif\n \nd\n \n \nself\n.\ncutoff\n:\n\n            \nself\n.\nresult\n \n=\n \nfr\n\n\n\n\n\n\nWith this customized analyzer, the usage code becomes\n\n\n# file loading is omitted \n\n\nspliter\n \n=\n \nSpliter\n(\nmsys_model\n,\n \ncms_model\n,\n \n1\n,\n \n50\n,\n \ncutoff\n=\n4.0\n)\n\n\nout_tr\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nspliter\n)\n\n\n\n\n\n\ndesign\n\n\nAt high level, the trajectory analysis process is as follows.\n\n\ncalc\n \n=\n \nGeomCalc\n()\n\n\n\n# each analyzer is an instance of a derived class of GeomAnalyzerBase\n\n\nfor\n \nana\n \nin\n \nanalyzers\n:\n  \n# both static and dynamic analyzers\n\n    \n# inside these _precalc() functions, elementary calculations are registered to\n\n    \n# calc._custom which is a _CustomCalc object\n\n    \n# these results are cached and shared among analyzers\n\n    \nana\n.\n_precalc\n(\ncalc\n)\n\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \n# perform per-frame initialization for dynamic analyzers\n\n    \nfor\n \nana\n \nin\n \ndynamic_analyzers\n:\n\n        \nana\n.\n_dyncalc\n(\nfr\n)\n\n    \n# perform registered elementary calculations\n\n    \ncalc\n(\nfr\n)\n\n    \n# perform further analyzer specific calculations\n\n    \nfor\n \nana\n \nin\n \nanalyzers\n:\n\n        \nana\n.\n_postcalc\n(\ncalc\n,\n \nfr\n)\n\n\n\n# this reduce process does not exist for all analyzers\n\n\nfor\n \nana\n \nin\n \nanalyzers\n:\n\n    \nana\n.\nreduce\n()\n\n\n\n\n\n\nThe design of trajectory analysis framework is a combination of \nstrategy pattern\n and \ntemplate pattern\n centered around the following three classes\n\n\n\n\nclass GeomCalc(object)\n\n\nclass GeomAnalyzerBase(object)\n\n\nclass _CustomCalc(OrderedDict)\n\n\n\n\n_CustomCalc\n is a dictionary (specifically \ncollections::OrderedDict\n) that caches all the elementary calculations for the analyzers.\nTypically its keys are function calls and the values are dictionaries whose key value pairs correspond to function call inputs (e.g., \ngids\n) and outputs.\nIts member function \n_CustomCalc.calc(pbc, fr)\n carries out all cached calculations for each frame.\n\n\nGeomCalc\n is a callable that contains a \n_CustomCalc\n instance for calculations.\nIt supports four basic geometric calculations which only require \ngids\n as inputs\n\n\n\n\nvector\n\n\ndistance\n\n\nangle\n\n\ntorsion\n\n\n\n\nThese calculations take care of the unwrapping of the periodic boundary condition.\nThere are also four analyzer classes to provide direct access to these calculations.\n\n\nGeomAnalyzerBase\n is the abstract base class for all trajectory analyzer class.\nIt is a callable that returns the calculation result.\n\n\nAll other analyzers are registered to the \nGeomCalc\n instance using \nGeomCalc.addAnalyzer(analyzer)\n.\nIn \nGeomAnalyzerBase._precalc(calc)\n, one should use \nGeomCalc.addCustom(cid, key, default)\n to register the elementary calculation.\nIn \nGeomAnalyzerBase._postcalc(calc, pbc, fr)\n, one should retrieve the results of the elementary calculation and perform further calculations if needed.\n\n\nanalyzer prototypes\n\n\nThere are four analyzer prototypes\n\n\n\n\nclass GeomAnalyzerBase(object)\n\n\nclass _MaestroAnalysis(GeomAnalyzerBase)\n\n\nclass _CompositeAnalyzer(GeomAnalyzerBase)\n\n\nclass CustomMaestroAnalysis(CustomMaestroAnalysis)\n\n\nclass _DynamicAslAnalyzer(GeomAnalyzerBase)\n\n\n\n\nHere \nGeomAnalyzerBase\n is an \nabstract base class\n. Here is an example that\nimplement analyzer .\n\n\nclass\n \nFooAnalyzer\n(\nGeomAnalyzerBase\n):\n\n    \ndef\n \n__init__\n(\nmsys_model\n,\n \ncms_model\n,\n \nlig_asl\n):\n\n        \n\n\n        @type msys_model: C{msys.System}\n\n\n        @type  cms_model: C{schrodinger.structure.Structure}\n\n\n        @type    lig_asl: C{str}\n\n\n        @param   lig_asl: ASL expression to select ligand atoms\n\n\n        \n\n        \nlig_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nlig_asl\n)\n\n        \nlig_gids\n \n=\n \ntopo\n.\naids2gids\n(\ncms_model\n,\n \nlig_aids\n,\n \ninclude_pseudoatoms\n=\nFalse\n)\n\n\n    \ndef\n \n_precalc\n(\nself\n,\n \ncalc\n):\n\n        \n\n\n        @type calc: L{GeomCalc}\n\n\n        \n\n        \n# to do some real work, use calc.addCustom() to register function calls\n\n        \npass\n\n\n\n    \ndef\n \n_postcalc\n(\nself\n,\n \ncalc\n,\n \npbc\n,\n \nfr\n):\n\n        \n\n\n        @type calc: L{GeomCalc}\n\n\n        @type  pbc: L{Pbc}\n\n\n        @type   fr: L{traj.Frame}\n\n\n        \n\n        \n# fr is the current frame \n\n        \n# one could use calc.getCustom() to retrieve intermediate calculation results\n\n        \npass\n\n\n\n\n\n\nThe intention of \n_MaestroAnalysis\n is to provide intermediate data (a frame and a full-system CT) with all the solute atoms centered.\n\n\nclass\n \nFooMaestroAnalyzer\n(\n_MaestroAnalysis\n):\n\n    \ndef\n \n__init__\n(\nmsys_model\n,\n \ncms_model\n,\n \nlig_asl\n):\n\n        \n\n\n        @type msys_model: C{msys.System}\n\n\n        @type  cms_model: C{schrodinger.structure.Structure}\n\n\n        @type    lig_asl: C{str}\n\n\n        @param   lig_asl: ASL expression to select ligand atoms\n\n\n        \n\n        \n_MaestroAnalysis\n.\n__init__\n(\nself\n,\n \nmsys_model\n,\n \ncms_model\n)\n\n        \nlig_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nlig_asl\n)\n\n        \nlig_gids\n \n=\n \ntopo\n.\naids2gids\n(\ncms_model\n,\n \nlig_aids\n,\n \ninclude_pseudoatoms\n=\nFalse\n)\n\n\n    \ndef\n \n_precalc\n(\nself\n,\n \ncalc\n):\n\n        \n\n\n        @type calc: L{GeomCalc}\n\n\n        \n\n        \n# to do some work beyond getting centered data,\n\n        \n# use calc.addCustom() to register function calls\n\n        \npass\n\n\n    \ndef\n \n_postcalc\n(\nself\n,\n \ncalc\n,\n \npbc\n,\n \nfr\n):\n\n        \n\n\n        @type calc: L{GeomCalc}\n\n\n        @type  pbc: L{Pbc}\n\n\n        @type   fr: L{traj.Frame}\n\n\n        \n\n        \n# fr is the current frame \n\n        \n# one could use calc.getCustom() to retrieve intermediate calculation results\n\n        \ncentered_fr\n,\n \ncentered_cms_model\n \n=\n \nself\n.\n_getCentered\n(\ncalc\n)\n\n        \npass\n\n\n\n\n\n\nThe intention of \n_CompositeAnalyzer\n is to simplify the implementation when one analyzer needs other analyzers as its helpers, i.e., the \ncomposition pattern\n.\n\n\nreduce mechanism\n\n\nThe design of the trajectory analysis classes aims to share auxiliary\ncalculation results between analyzers for each frame. \nHowever, no information is shared between frames.\nThe reduce mechanism uses the results from all frames as input for trajectory-wise\nanalysis, for example, performing statistics, etc.\n\n\nmore advanced topics\n\n\na tale of three IDs\n\n\nThere are three types of IDs in use\n\n\n\n\nAID: index used by the maestro which starts from 1\n\n\ncms_model\n\n\nct\n\n\n\n\n\n\nGID: index used by the msys_model which starts from 0\n\n\nmsys_model\n\n\nframe objects\n\n\n\n\n\n\nXID\n\n\nframe objects\n\n\n\n\n\n\n\n\npositer mechanism\n\n\nThe positer mechanism enables uniform treatment of \n\n\n\n\natom\n\n\ncentroid of a group of atoms\n\n\ncenter of mass of a group of atoms\n\n\ncenter of charge of a group of atoms\n\n\n\n\nIt has \nside effect\n: extra \ngids\n will be created in the frame object.\n\n\nclass Positer(object)\n\n\nEach class instance works with two  \nGeomCalc\n objects\n\n\n\n\nan internal \nGeomCalc\n object that computes the results of the \nCenterOf\n analyzers\n\n\nan external \nGeomCalc\n object that keeps track of the index of the extra \ngids\n\n\n\n\npositer\n \n=\n \nPositer\n(,\n \n)\n\n\next_calc\n.\naddPosition\n(\npositer\n,\n \nnum_pos\n)\n\n\n\n\n\n\nUsing the \nDynamicAslAnalyzer\n\n\nThe", 
            "title": "Customized analyzers"
        }, 
        {
            "location": "/custom-analyzer/#overview", 
            "text": "This section is for developers who want to write customized trajectory analyzers.\nIt can be skipped if you are satisfied as a user of the existing analyzers.  The main reason to write customized analyzer is code decoupling.  As an introductory example, let's filter a trajectory according to a user\nselected distance cutoff between two atoms.  # file loading is omitted   dist_ana   =   analysis . Distance ( msys_model ,   cms_model ,   1 ,   50 )    # atom 1 and 50 are chosen  distances   =   analysis . analyze ( tr ,   dist_ana )  out_tr   =   []  for   fr ,   d   in   zip ( tr ,   distances ): \n     if   d     4.0 :    # 4.0 is the chosen cutoff \n         out_tr . append ( fr )   The following class is an example of customized analyzer for the same task,  class   Spliter ( staf . GeomAnalyzerBase ): \n     def   __init__ ( self ,   msys_model ,   cms_model ,   atom1 ,   atom2 ,   cutoff = 1 ): \n         self . gids   =   topo . aids2gids ([ atom1 ,   atom2 ],   include_pseudoatoms = False ) \n\n     def   _precalc ( self ,   calc ): \n         calc . addDistance ( self . gids [ 0 ],   self . gids [ 1 ]) \n\n     def   _postcalc ( self ,   calc ,   pbc ,   fr ): \n         d   =   calc . getDistance ( self . gids [ 0 ],   self . gids [ 1 ]) \n         if   d     self . cutoff : \n             self . result   =   fr   With this customized analyzer, the usage code becomes  # file loading is omitted   spliter   =   Spliter ( msys_model ,   cms_model ,   1 ,   50 ,   cutoff = 4.0 )  out_tr   =   analysis . analyze ( tr ,   spliter )", 
            "title": "overview"
        }, 
        {
            "location": "/custom-analyzer/#design", 
            "text": "At high level, the trajectory analysis process is as follows.  calc   =   GeomCalc ()  # each analyzer is an instance of a derived class of GeomAnalyzerBase  for   ana   in   analyzers :    # both static and dynamic analyzers \n     # inside these _precalc() functions, elementary calculations are registered to \n     # calc._custom which is a _CustomCalc object \n     # these results are cached and shared among analyzers \n     ana . _precalc ( calc )  for   fr   in   tr : \n     # perform per-frame initialization for dynamic analyzers \n     for   ana   in   dynamic_analyzers : \n         ana . _dyncalc ( fr ) \n     # perform registered elementary calculations \n     calc ( fr ) \n     # perform further analyzer specific calculations \n     for   ana   in   analyzers : \n         ana . _postcalc ( calc ,   fr )  # this reduce process does not exist for all analyzers  for   ana   in   analyzers : \n     ana . reduce ()   The design of trajectory analysis framework is a combination of  strategy pattern  and  template pattern  centered around the following three classes   class GeomCalc(object)  class GeomAnalyzerBase(object)  class _CustomCalc(OrderedDict)   _CustomCalc  is a dictionary (specifically  collections::OrderedDict ) that caches all the elementary calculations for the analyzers.\nTypically its keys are function calls and the values are dictionaries whose key value pairs correspond to function call inputs (e.g.,  gids ) and outputs.\nIts member function  _CustomCalc.calc(pbc, fr)  carries out all cached calculations for each frame.  GeomCalc  is a callable that contains a  _CustomCalc  instance for calculations.\nIt supports four basic geometric calculations which only require  gids  as inputs   vector  distance  angle  torsion   These calculations take care of the unwrapping of the periodic boundary condition.\nThere are also four analyzer classes to provide direct access to these calculations.  GeomAnalyzerBase  is the abstract base class for all trajectory analyzer class.\nIt is a callable that returns the calculation result.  All other analyzers are registered to the  GeomCalc  instance using  GeomCalc.addAnalyzer(analyzer) .\nIn  GeomAnalyzerBase._precalc(calc) , one should use  GeomCalc.addCustom(cid, key, default)  to register the elementary calculation.\nIn  GeomAnalyzerBase._postcalc(calc, pbc, fr) , one should retrieve the results of the elementary calculation and perform further calculations if needed.", 
            "title": "design"
        }, 
        {
            "location": "/custom-analyzer/#analyzer-prototypes", 
            "text": "There are four analyzer prototypes   class GeomAnalyzerBase(object)  class _MaestroAnalysis(GeomAnalyzerBase)  class _CompositeAnalyzer(GeomAnalyzerBase)  class CustomMaestroAnalysis(CustomMaestroAnalysis)  class _DynamicAslAnalyzer(GeomAnalyzerBase)   Here  GeomAnalyzerBase  is an  abstract base class . Here is an example that\nimplement analyzer .  class   FooAnalyzer ( GeomAnalyzerBase ): \n     def   __init__ ( msys_model ,   cms_model ,   lig_asl ): \n                  @type msys_model: C{msys.System}          @type  cms_model: C{schrodinger.structure.Structure}          @type    lig_asl: C{str}          @param   lig_asl: ASL expression to select ligand atoms           \n         lig_aids   =   cms_model . select_atom ( lig_asl ) \n         lig_gids   =   topo . aids2gids ( cms_model ,   lig_aids ,   include_pseudoatoms = False ) \n\n     def   _precalc ( self ,   calc ): \n                  @type calc: L{GeomCalc}           \n         # to do some real work, use calc.addCustom() to register function calls \n         pass \n\n\n     def   _postcalc ( self ,   calc ,   pbc ,   fr ): \n                  @type calc: L{GeomCalc}          @type  pbc: L{Pbc}          @type   fr: L{traj.Frame}           \n         # fr is the current frame  \n         # one could use calc.getCustom() to retrieve intermediate calculation results \n         pass   The intention of  _MaestroAnalysis  is to provide intermediate data (a frame and a full-system CT) with all the solute atoms centered.  class   FooMaestroAnalyzer ( _MaestroAnalysis ): \n     def   __init__ ( msys_model ,   cms_model ,   lig_asl ): \n                  @type msys_model: C{msys.System}          @type  cms_model: C{schrodinger.structure.Structure}          @type    lig_asl: C{str}          @param   lig_asl: ASL expression to select ligand atoms           \n         _MaestroAnalysis . __init__ ( self ,   msys_model ,   cms_model ) \n         lig_aids   =   cms_model . select_atom ( lig_asl ) \n         lig_gids   =   topo . aids2gids ( cms_model ,   lig_aids ,   include_pseudoatoms = False ) \n\n     def   _precalc ( self ,   calc ): \n                  @type calc: L{GeomCalc}           \n         # to do some work beyond getting centered data, \n         # use calc.addCustom() to register function calls \n         pass \n\n     def   _postcalc ( self ,   calc ,   pbc ,   fr ): \n                  @type calc: L{GeomCalc}          @type  pbc: L{Pbc}          @type   fr: L{traj.Frame}           \n         # fr is the current frame  \n         # one could use calc.getCustom() to retrieve intermediate calculation results \n         centered_fr ,   centered_cms_model   =   self . _getCentered ( calc ) \n         pass   The intention of  _CompositeAnalyzer  is to simplify the implementation when one analyzer needs other analyzers as its helpers, i.e., the  composition pattern .", 
            "title": "analyzer prototypes"
        }, 
        {
            "location": "/custom-analyzer/#reduce-mechanism", 
            "text": "The design of the trajectory analysis classes aims to share auxiliary\ncalculation results between analyzers for each frame. \nHowever, no information is shared between frames.\nThe reduce mechanism uses the results from all frames as input for trajectory-wise\nanalysis, for example, performing statistics, etc.", 
            "title": "reduce mechanism"
        }, 
        {
            "location": "/custom-analyzer/#more-advanced-topics", 
            "text": "", 
            "title": "more advanced topics"
        }, 
        {
            "location": "/custom-analyzer/#a-tale-of-three-ids", 
            "text": "There are three types of IDs in use   AID: index used by the maestro which starts from 1  cms_model  ct    GID: index used by the msys_model which starts from 0  msys_model  frame objects    XID  frame objects", 
            "title": "a tale of three IDs"
        }, 
        {
            "location": "/custom-analyzer/#positer-mechanism", 
            "text": "The positer mechanism enables uniform treatment of    atom  centroid of a group of atoms  center of mass of a group of atoms  center of charge of a group of atoms   It has  side effect : extra  gids  will be created in the frame object.  class Positer(object)  Each class instance works with two   GeomCalc  objects   an internal  GeomCalc  object that computes the results of the  CenterOf  analyzers  an external  GeomCalc  object that keeps track of the index of the extra  gids   positer   =   Positer (,   )  ext_calc . addPosition ( positer ,   num_pos )", 
            "title": "positer mechanism"
        }, 
        {
            "location": "/custom-analyzer/#using-the-dynamicaslanalyzer", 
            "text": "The", 
            "title": "Using the DynamicAslAnalyzer"
        }
    ]
}