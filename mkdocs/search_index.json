{
    "docs": [
        {
            "location": "/", 
            "text": "highlights\n\n\nCompared to the old trajectory infrastructure, the new one perform better (faster, more robust) in the following aspects\n\n\n\n\ntracking virtual sites (pseudo atoms)\n\n\nhandling triclinic systems and orthorhombic systems whose primitive cell vectors do not align with the axes\n\n\nunwrapping coordinates around periodic boundary condition (automatically or manually)\n\n\n\n\nmodule changes\n\n\nThe following modules are deprecated\n\nschrodinger\n.\ntrajectory\n\n\nschrodinger\n.\ninfra\n.\ndesmond\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\ndestro\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\nperiodicfix\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\nframesettools\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\ngenerictrajectory\n\n\n\n\n\n\nAnd the replacements are\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ntopo\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ntraj\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ntraj_util\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\nanalysis\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\ndestro\n\n\nschrodinger\n.\napplication\n.\ndesmond\n.\npackages\n.\nstaf\n\n\n\n\n\n\n\n\ntopo: \nCms\n object manipulation, GID tracking/conversion\n\n\ntraj and traj_util: definition of the new \nFrame\n object, trajectory read/write\n\n\nanalysis: definition of various trajectory analyzers (see below)\n\n\ndestro: the maeff class enables low-level mae file IO (try to avoid using it if you can, it bypasses all python-level and swig-level APIs)\n\n\nstaf: abstract base classes for trajectory analyzers\n\n\n\n\nanalyzers in the new trajectory infrastructure\n\n\n\n\nbasic geometric operations\n\n\nAngle\n\n\nDistance\n\n\nPlanarAngle\n\n\nTorsion\n\n\nVector\n\n\n\n\n\n\nCenterOf\n\n\nCentroid\n\n\nCoC\n: center of charge\n\n\nCom\n: center of mass\n\n\n\n\n\n\nDipole\n\n\nGyradius\n: radius of gyration\n\n\nHydrogenBondFinder\n\n\nMassAvgVel\n: mass-averaged velocity\n\n\nMolecularSurfaceArea\n\n\nMomentOfInertia\n\n\nOrderParameter\n\n\nthe following analyzers are inputs to \nOrderParameter\n\n\nAxisDirector\n\n\nDipoleDirector\n\n\nLipidDirector\n\n\nsn1\n\n\nsn2\n\n\nall\n\n\n\n\n\n\nMomentOfInertiaDirector\n\n\nSmartsDirector\n\n\nSystemDipoleDirector\n\n\n\n\n\n\n\n\n\n\nPolarSurfaceArea\n\n\nPosAlign\n: align positions\n\n\nRMSD\n: Root mean square deviation\n\n\nLigandRMSD\n: further includes symmetry consideration\n\n\n\n\n\n\nRMSF\n: Root mean square fluctuation\n\n\nProteinRMSF\n\n\n\n\n\n\nCovarianceMatrix\n\n\n\n\n\n\nPosTrack\n: track positions of selected atoms in a trajectory\n\n\nProtLigInter\n: Protein-ligand interactions\n\n\nHydrophobicInter\n, `_HydrophobicInter\n\n\nMetalInter\n\n\nProtLigHbondInter\n\n\nProtLigPiInter\n\n\nProtLigPolarInter\n, \n_ProtLigPolarInter\n\n\nWaterBridges\n\n\nWatLigFragDistance\n, \n_WatLigFragDistance\n\n\n\n\n\n\nProtProtInter\n: Protein-protein interactions\n\n\nProtProtHbondInter\n\n\nProtProtPiInter\n\n\nProtProtSaltBridges\n\n\n\n\n\n\nRdf\n: Radial distribution function\n\n\nRamachandran\n\n\nSecondaryStructure\n\n\nSaltBridgeFinder\n\n\nSolventAccessibleSurfaceArea\n\n\nSolventAccessibleSurfaceAreaByResidue\n\n\nVolumeMapper\n\n\n\n\nIn case you want to write customerized analyzer, I can share another document with you.", 
            "title": "Home"
        }, 
        {
            "location": "/#highlights", 
            "text": "Compared to the old trajectory infrastructure, the new one perform better (faster, more robust) in the following aspects   tracking virtual sites (pseudo atoms)  handling triclinic systems and orthorhombic systems whose primitive cell vectors do not align with the axes  unwrapping coordinates around periodic boundary condition (automatically or manually)", 
            "title": "highlights"
        }, 
        {
            "location": "/#module-changes", 
            "text": "The following modules are deprecated schrodinger . trajectory  schrodinger . infra . desmond  schrodinger . application . desmond . destro  schrodinger . application . desmond . periodicfix  schrodinger . application . desmond . framesettools  schrodinger . application . desmond . generictrajectory    And the replacements are schrodinger . application . desmond . packages . topo  schrodinger . application . desmond . packages . traj  schrodinger . application . desmond . packages . traj_util  schrodinger . application . desmond . packages . analysis  schrodinger . application . desmond . packages . destro  schrodinger . application . desmond . packages . staf     topo:  Cms  object manipulation, GID tracking/conversion  traj and traj_util: definition of the new  Frame  object, trajectory read/write  analysis: definition of various trajectory analyzers (see below)  destro: the maeff class enables low-level mae file IO (try to avoid using it if you can, it bypasses all python-level and swig-level APIs)  staf: abstract base classes for trajectory analyzers", 
            "title": "module changes"
        }, 
        {
            "location": "/#analyzers-in-the-new-trajectory-infrastructure", 
            "text": "basic geometric operations  Angle  Distance  PlanarAngle  Torsion  Vector    CenterOf  Centroid  CoC : center of charge  Com : center of mass    Dipole  Gyradius : radius of gyration  HydrogenBondFinder  MassAvgVel : mass-averaged velocity  MolecularSurfaceArea  MomentOfInertia  OrderParameter  the following analyzers are inputs to  OrderParameter  AxisDirector  DipoleDirector  LipidDirector  sn1  sn2  all    MomentOfInertiaDirector  SmartsDirector  SystemDipoleDirector      PolarSurfaceArea  PosAlign : align positions  RMSD : Root mean square deviation  LigandRMSD : further includes symmetry consideration    RMSF : Root mean square fluctuation  ProteinRMSF    CovarianceMatrix    PosTrack : track positions of selected atoms in a trajectory  ProtLigInter : Protein-ligand interactions  HydrophobicInter , `_HydrophobicInter  MetalInter  ProtLigHbondInter  ProtLigPiInter  ProtLigPolarInter ,  _ProtLigPolarInter  WaterBridges  WatLigFragDistance ,  _WatLigFragDistance    ProtProtInter : Protein-protein interactions  ProtProtHbondInter  ProtProtPiInter  ProtProtSaltBridges    Rdf : Radial distribution function  Ramachandran  SecondaryStructure  SaltBridgeFinder  SolventAccessibleSurfaceArea  SolventAccessibleSurfaceAreaByResidue  VolumeMapper   In case you want to write customerized analyzer, I can share another document with you.", 
            "title": "analyzers in the new trajectory infrastructure"
        }, 
        {
            "location": "/fundamentals/", 
            "text": "introduction\n\n\nRoughly speaking, here are the correspondences between the old and new infrastructures:\n\n\n\n\n\n\n\n\nold\n\n\nnew\n\n\n\n\n\n\n\n\n\n\nDesmondSimulation\n or \nChorusSimulation\n object\n\n\nCms\n object and trajectory object\n\n\n\n\n\n\n_DesmondFrame\n object\n\n\ntraj.Frame\n object\n\n\n\n\n\n\nschrodinger.infra.desmond.Trajectory\n or \nframesettools.Frameset\n\n\npython list of \ntraj.Frame\n objects\n\n\n\n\n\n\n\n\nNote that\n\n\n\n\nThe new frame object is different from the old one.\n\n\nThe new trajectory object is simply a python list of \ntraj.Frame\n objects\n\n\nThe following properties and function calls are guaranteed for a frame object\n\n\nfr.natoms\n: pseudo-atoms are included\n\n\nfr.pos()\n, \nfr.pos(gids)\n, \nfr.pos(gid)\n\n\nfr.time\n\n\nfr.box\n\n\n\n\n\n\nThe function call \nfr.vel()\n is not guaranteed. XTC data will not have this, DTR data may not have it either.\n\n\nIf the data is DTR, you may be able to pull out more (private) information such as \nfr._frame().temperature\n. Use with your own risk.\n\n\n\n\nminimum examples\n\n\nThe CMS files contain structures for MD related workflows.\nThe first structure is the full system CT used for Maestro display.\nThe rest are component CTs.\n\n\nThere are three ways to read a CMS file\n\n\nimport\n \nschrodinger.structure\n \nas\n \nstructure\n\n\nst_reader\n \n=\n \nstructure\n.\nStructureReader\n(\nexample-out.cms\n)\n\n\ncts\n \n=\n \nlist\n(\nst_reader\n)\n\n\n\n\n\n\nfrom\n \nschrodinger.application.desmond.cms\n \nimport\n \nCms\n\n\ncms_model\n \n=\n \nCms\n(\nexample-out.cms\n)\n\n\n\n\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_file_name\n)\n\n\n\n\n\n\nThe loading speed decreases for the latter methods. But more information become available in the latter methods as well.\nFor trajectory analysis, the third method is the preferred one as often times an \nmsys_model\n is needed for trajectory analysis.\n\n\nTo read a trajectory\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\n\n\n\n\nHere \ntr\n is simply a python list of trajectory \nFrame\n objects.\n\n\nTo do some analysis using existing analyzers\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \nanalysis\n,\n \ntraj\n,\n \ntopo\n\n\n\n# load data\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nFNAME\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\nTRJ_FNAME\n)\n\n\n\n# define analyzers\n\n\nanalyzer1\n \n=\n \nanalysis\n.\nCom\n(\nmsys_model\n,\n \ncms_model\n,\n \nasl\n=\nm.n 1\n)\n\n\nanalyzer2\n \n=\n \nanalysis\n.\nProtLigInter\n(\nmsys_model\n,\n \ncms_model\n,\n \nprotein\n,\n \nm.n 2\n)\n\n\n\n# compute result\n\n\nresults\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n,\n \nanalyzer2\n,\n \n)\n\n\n\n\n\n\nThe \nresults\n is a list of the analyzers' output.\nIn the above example, \nresults\n is a list of 2 items, corresponding to the output of the two analyzers.\n\n\nThe analyzers' output format varies.\nTypically, the output is a list of frame-wise results.\n\n\natom AIDs and atom GIDs\n\n\nIn MD simulation, there are two types of atoms\n\n\n\n\nphysical atoms\n\n\npseudo atoms (virtual sites): They have fractional charge and 0 mass. They are used to model forcefield better.\n\n\n\n\nIn Maestro, the pseudo atoms are not displayed.\n\n\nTo keep track of the atoms, there are two types of IDs\n\n\n\n\nAID stands for Atom ID, defined as the atom index in the full system ct (it is the same as \ncms_model.atom.index\n). It starts with 1.\n\n\nGID stands for Global ID, defined as the particle index in the Desmond internal particle array. It starts with 0.\n\n\n\n\nNote that\n\n\n\n\nPseudo atoms do not have AID.\n\n\nIf no pseudo atoms are present, then \nAID = GID + 1\n. In general, one cannot rely on this.\n\n\n\n\nTo access a particle's coordinate in the trajectory (i.e., the \ntraj.Frame\n object), you have to use GID.\nWe have functions to map AID to GID in the \ntopo\n module. For example,\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_filename\n)\n\n\nprotein_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nprotein_asl\n)\n\n\nprotein_gids\n \n=\n \ntopo\n.\naids2gids\n(\ncms_model\n,\n \nprotein_aids\n,\n\n                              \ninclude_pseudoatoms\n=\nFalse\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nfr\n.\npos\n(\nprotein_gids\n)\n\n    \nfr\n.\nvel\n(\nprotein_gids\n)\n\n\n\n\nBoth \ntraj.Frame.pos()\n and \ntraj.Frame.vel()\n return Nx3 numpy arrays,\nWithout argument input, they return the positions or velocities of all atoms.\nWith GIDs input, the order of the output follows the order of the GID input.\nFor example \n\n\nIn [8]: fr0.pos([2,3])\nOut[8]:\narray([[-4.77608204,  3.04622388,  1.31021202],\n       [-5.66208792,  1.88501239,  0.96774006]], dtype=float32)\n\nIn [9]: fr0.pos([3,2])\nOut[9]:\narray([[-5.66208792,  1.88501239,  0.96774006],\n       [-4.77608204,  3.04622388,  1.31021202]], dtype=float32)\n\n\n\n\n\nOne can use the GID directly to get the single atom coordinate too\n\nIn [7]: fr0.pos(0)\nOut[7]: array([-0.76461941, -2.64227247, -0.62481445], dtype=float32)\n\n\n\n\n\nNote that\n\n\n\n\nvel()\n may not exist. Default MD simulation does not save velocities, also the XTC format trajectories do not contain velocities.\n\n\nIf you get positions this way, then you need to worry about unwrapping around PBC yourself. If you don't want to unwrap yourself, try use the existing mechanisms in the infrastructure. See \nthis paradigm\n.\n\n\n\n\nASL and SMARTS evaluations only return AIDs. In other words, they only select physical atoms.\nThere are two helper functions in the topo module to select GIDS:\n\ntopo.asl2gids()\ntopo.aids2gids()", 
            "title": "Fundamentals"
        }, 
        {
            "location": "/fundamentals/#introduction", 
            "text": "Roughly speaking, here are the correspondences between the old and new infrastructures:     old  new      DesmondSimulation  or  ChorusSimulation  object  Cms  object and trajectory object    _DesmondFrame  object  traj.Frame  object    schrodinger.infra.desmond.Trajectory  or  framesettools.Frameset  python list of  traj.Frame  objects     Note that   The new frame object is different from the old one.  The new trajectory object is simply a python list of  traj.Frame  objects  The following properties and function calls are guaranteed for a frame object  fr.natoms : pseudo-atoms are included  fr.pos() ,  fr.pos(gids) ,  fr.pos(gid)  fr.time  fr.box    The function call  fr.vel()  is not guaranteed. XTC data will not have this, DTR data may not have it either.  If the data is DTR, you may be able to pull out more (private) information such as  fr._frame().temperature . Use with your own risk.", 
            "title": "introduction"
        }, 
        {
            "location": "/fundamentals/#minimum-examples", 
            "text": "The CMS files contain structures for MD related workflows.\nThe first structure is the full system CT used for Maestro display.\nThe rest are component CTs.  There are three ways to read a CMS file  import   schrodinger.structure   as   structure  st_reader   =   structure . StructureReader ( example-out.cms )  cts   =   list ( st_reader )   from   schrodinger.application.desmond.cms   import   Cms  cms_model   =   Cms ( example-out.cms )   import   schrodinger.application.desmond.packages.topo   as   topo  msys_model ,   cms_model   =   topo . read_cms ( cms_file_name )   The loading speed decreases for the latter methods. But more information become available in the latter methods as well.\nFor trajectory analysis, the third method is the preferred one as often times an  msys_model  is needed for trajectory analysis.  To read a trajectory import   schrodinger.application.desmond.packages.traj   as   traj  tr   =   traj . read_traj ( trajectory_directory )    Here  tr  is simply a python list of trajectory  Frame  objects.  To do some analysis using existing analyzers  from   schrodinger.application.desmond.packages   import   analysis ,   traj ,   topo  # load data  msys_model ,   cms_model   =   topo . read_cms ( FNAME )  tr   =   traj . read_traj ( TRJ_FNAME )  # define analyzers  analyzer1   =   analysis . Com ( msys_model ,   cms_model ,   asl = m.n 1 )  analyzer2   =   analysis . ProtLigInter ( msys_model ,   cms_model ,   protein ,   m.n 2 )  # compute result  results   =   analysis . analyze ( tr ,   analyzer1 ,   analyzer2 ,   )   The  results  is a list of the analyzers' output.\nIn the above example,  results  is a list of 2 items, corresponding to the output of the two analyzers.  The analyzers' output format varies.\nTypically, the output is a list of frame-wise results.", 
            "title": "minimum examples"
        }, 
        {
            "location": "/fundamentals/#atom-aids-and-atom-gids", 
            "text": "In MD simulation, there are two types of atoms   physical atoms  pseudo atoms (virtual sites): They have fractional charge and 0 mass. They are used to model forcefield better.   In Maestro, the pseudo atoms are not displayed.  To keep track of the atoms, there are two types of IDs   AID stands for Atom ID, defined as the atom index in the full system ct (it is the same as  cms_model.atom.index ). It starts with 1.  GID stands for Global ID, defined as the particle index in the Desmond internal particle array. It starts with 0.   Note that   Pseudo atoms do not have AID.  If no pseudo atoms are present, then  AID = GID + 1 . In general, one cannot rely on this.   To access a particle's coordinate in the trajectory (i.e., the  traj.Frame  object), you have to use GID.\nWe have functions to map AID to GID in the  topo  module. For example,  import   schrodinger.application.desmond.packages.topo   as   topo  import   schrodinger.application.desmond.packages.traj   as   traj  _ ,   cms_model   =   topo . read_cms ( cms_filename )  protein_aids   =   cms_model . select_atom ( protein_asl )  protein_gids   =   topo . aids2gids ( cms_model ,   protein_aids , \n                               include_pseudoatoms = False )  tr   =   traj . read_traj ( trajectory_directory )  for   fr   in   tr : \n     fr . pos ( protein_gids ) \n     fr . vel ( protein_gids )  \n\nBoth  traj.Frame.pos()  and  traj.Frame.vel()  return Nx3 numpy arrays,\nWithout argument input, they return the positions or velocities of all atoms.\nWith GIDs input, the order of the output follows the order of the GID input.\nFor example   In [8]: fr0.pos([2,3])\nOut[8]:\narray([[-4.77608204,  3.04622388,  1.31021202],\n       [-5.66208792,  1.88501239,  0.96774006]], dtype=float32)\n\nIn [9]: fr0.pos([3,2])\nOut[9]:\narray([[-5.66208792,  1.88501239,  0.96774006],\n       [-4.77608204,  3.04622388,  1.31021202]], dtype=float32)  One can use the GID directly to get the single atom coordinate too In [7]: fr0.pos(0)\nOut[7]: array([-0.76461941, -2.64227247, -0.62481445], dtype=float32)   Note that   vel()  may not exist. Default MD simulation does not save velocities, also the XTC format trajectories do not contain velocities.  If you get positions this way, then you need to worry about unwrapping around PBC yourself. If you don't want to unwrap yourself, try use the existing mechanisms in the infrastructure. See  this paradigm .   ASL and SMARTS evaluations only return AIDs. In other words, they only select physical atoms.\nThere are two helper functions in the topo module to select GIDS: topo.asl2gids()\ntopo.aids2gids()", 
            "title": "atom AIDs and atom GIDs"
        }, 
        {
            "location": "/paradigms/", 
            "text": "load both cms file and trajectory in case trajectory path is not specified\n\n\nIdeally, the user should specify the paths for both the cms file and the trajectory file.\nIn case the trajectory path is missing, one should make sure\n\n\n\n\nthe cms file and trajectory file are in the same directory\n\n\nthe \ns_chorus_trajectory_file\n property in the cms file points to the relative path of the trajectory file\n\n\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nargs\n.\ncms_file\n)\n\n\ntrj_path\n \n=\n \ntopo\n.\nfind_traj_path\n(\ncms_model\n,\n \nos\n.\npath\n.\ndirname\n(\nargs\n.\ncms_file\n))\n\n\nif\n \ntrj_path\n \nis\n \nNone\n:\n\n    \nparser\n.\nerror\n(\nCould not locate a trajectory directory for given CMS file\n)\n\n\ntry\n:\n\n    \ntrj\n \n=\n \ntraj\n.\nread_traj\n(\ntrj_path\n)\n\n\nexcept\n \nException\n \nas\n \ne\n:\n\n    \nparser\n.\nerror\n(\nCannot load trajectory file: \n%s\n \n%\n \ne\n)\n\n\n\n\n\n\nFor GUI, often times one only needs to get the trajectory path from the cms file path, then the following code can be used\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\n\ntrj_path\n \n=\n \ntopo\n.\nfind_traj_path_from_cms_path\n(\ncms_path\n)\n\n\n\n\n\n\nNote one should still check whether \ntrj_path\n is \nNone\n and do \ntry except\n for \ntraj.read_traj\n.\n\n\nAnother useful helper function to load both \ncms_model\n and trajectory is \nread_cms_and_traj\n\n\nfrom schrodinger.application.desmond.packages import traj_util\n\ntry:\n    _, cms_model, trj = traj_util.read_cms_and_traj(cmsfile)\nexcept traj_util.TrajectoryUnreadableError as err:\n    print(err)\n    sys.exit(1)\n\n\n\n\n\nextract structure once and per frame update coordinates instead of per frame update full system ct and extract structure\n\n\nNote that although one can get the full system ct per frame in new trajectory infrastructure, it is likely the inefficient approach.\nIn most cases, the user does not need to track the full system ct over the frames.\nInstead, only specific group of atoms or molecules needs to be tracked over the frames.\nIn these situations, it is more efficient to\n\n\n\n\nextract the atoms or molecules into a structure once\n\n\nkeep updating (or maybe only read) the coordinates of the selected atoms or molecules frame by frame\n\n\n\n\nIf the analysis is fully geometric, then the structure extraction can be avoided as well.\n\n\nHere is an example\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_filename\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\nprotein_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nprotein_asl\n)\n\n\nprotein_gids\n \n=\n \ntopo\n.\naids2gids\n(\ncms_model\n,\n \nprotein_aids\n,\n\n                              \ninclude_pseudoatoms\n=\nFalse\n)\n\n\nprotein_st\n \n=\n \ncms_model\n.\nextract\n(\nprotein_aids\n)\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nprotein_st\n.\nsetXYZ\n(\nfr\n.\npos\n(\nprotein_gids\n))\n\n    \n# what needs to be done on the protein structure\n\n    \n...\n\n\n\n\n\n\nThis is better than\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\ncms_filename\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\nprotein_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nprotein_asl\n)\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nupdated_cms\n \n=\n \ntopo\n.\nupdate_fsys_ct\n(\ncms_model\n,\n \nfr\n)\n\n    \nprotein_st\n \n=\n \nupdated_cms\n.\nextract\n(\nprotein_aids\n)\n\n    \n# what needs to be done on the protein structure\n\n    \n...\n\n\n\n\n\n\ntry avoid unwrap coordinates around periodic boundary conditions yourself\n\n\nThere are mechanisms in the new trajectory infrastructure to do these unwrapping for you. The relevant analyzer classes are\n\n\n\n\nbasic geometric operations\n\n\nAngle\n\n\nDistance\n\n\nTorsion\n\n\nVector\n\n\n\n\n\n\nCenterOf\n\n\nCentroid\n\n\nCoC\n: center of charge\n\n\nCom\n: center of mass\n\n\n\n\n\n\n\n\nYou can even measure geometric quantity between (among) center of mass objects/atoms (see example below), etc.\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \nanalysis\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \ntraj\n\n\nfrom\n \nschrodinger.application.desmond.packages\n \nimport\n \ntopo\n\n\n\n# load data\n\n\nmsys_model\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nFNAME\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\nTRJ_FNAME\n)\n\n\n\n# define analyzers\n\n\nanalyzer1\n \n=\n \nanalysis\n.\nCom\n(\nmsys_model\n,\n \ncms_model\n,\n \nasl\n=\nmy_asl\n)\n\n\nana_vector\n \n=\n \nanalysis\n.\nVector\n(\nmsys_model\n,\n \ncms_model\n,\n \n1\n,\n \n10\n)\n\n\nanalyzer3\n \n=\n \nanalysis\n.\nProtLigInter\n(\nmsys_model\n,\n \ncms_model\n,\n \nprotein\n,\n \nm.n 2\n)\n\n\ns5\n \n=\n \nanalysis\n.\nCom\n(\nself\n.\nmsys_model\n,\n \nself\n.\ncms_model\n,\n \nasl\n=\nnot atom.num 17\n)\n  \n# this doesn\nt need to be passed to analysis.analyze\n\n\ndist_com_atm\n \n=\n \nanalysis\n.\nDistance\n(\nself\n.\nmsys_model\n,\n \nself\n.\ncms_model\n,\n \ns5\n,\n \n10\n)\n\n\n\n# compute result\n\n\nresults\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n,\n \nana_vector\n,\n \nanalyzer3\n,\n \ndist_com_atm\n)\n\n\n\n\n\n\nIf you have to unwrap yourself, use the \nanalysis.Pbc\n class. Also note that the simulation box may change from frame to frame, e.g. in NPT systems. Thus the \nanalysis.Pbc\n object needs to be updated frame by frame.\n\n\nNote that the \ncircular mean algorithm\n is used to calculate geometric centers.\nThus it will fail if both of the following conditions apply\n* the selected atoms have a spatial extent comparable to the simulation box\n* the selected atoms do not form a blob-like shape (e.g., dumbbell)\n\n\nanalyze all together instead of one by one\n\n\nIf multiple analyzers can share some intermediate calculations, \nthere is a good chance that the new trajectory analysis framework calculates these intermediate results only once.\nThus it is more efficient to call \nanalysis.analyze\n with all analyzers together instead of calling \nanalysis.analyze\n multiple times.\n\n\nThus\n\nresults\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n,\n \nanalyzer2\n,\n \nanalyzer3\n)\n\n\n\n\n\n\nis better than\n\nresult1\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer1\n)\n\n\nresult2\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer2\n)\n\n\nresult3\n \n=\n \nanalysis\n.\nanalyze\n(\ntr\n,\n \nanalyzer3\n)\n\n\n\n\n\n\ntesting\n\n\nThe new trajectory modules are in the desmond package.\nThus if you are working on a non-desmond repo and uses trajectory stuff, test has to be written in the following way\n\n\n\n\nuse \ntest_marker.require_product('desmond')\n\n\nlazy import the trajectory handling modules\n\n\n\n\nimport\n \npytest\n\n\n\n# Lazy import, in case desmond is not installed\n\n\nmf\n \n=\n \nNone\n\n\n\n@pytest.fixture\n(\nscope\n=\nmodule\n,\n \nautouse\n=\nTrue\n)\n\n\ndef\n \nimport_my_file\n():\n\n    \nglobal\n \nmf\n\n    \nimport\n \nmy_file\n \nas\n \nmf", 
            "title": "Paradigms"
        }, 
        {
            "location": "/paradigms/#load-both-cms-file-and-trajectory-in-case-trajectory-path-is-not-specified", 
            "text": "Ideally, the user should specify the paths for both the cms file and the trajectory file.\nIn case the trajectory path is missing, one should make sure   the cms file and trajectory file are in the same directory  the  s_chorus_trajectory_file  property in the cms file points to the relative path of the trajectory file   import   schrodinger.application.desmond.packages.topo   as   topo  import   schrodinger.application.desmond.packages.traj   as   traj  msys_model ,   cms_model   =   topo . read_cms ( args . cms_file )  trj_path   =   topo . find_traj_path ( cms_model ,   os . path . dirname ( args . cms_file ))  if   trj_path   is   None : \n     parser . error ( Could not locate a trajectory directory for given CMS file )  try : \n     trj   =   traj . read_traj ( trj_path )  except   Exception   as   e : \n     parser . error ( Cannot load trajectory file:  %s   %   e )   For GUI, often times one only needs to get the trajectory path from the cms file path, then the following code can be used  import   schrodinger.application.desmond.packages.topo   as   topo  trj_path   =   topo . find_traj_path_from_cms_path ( cms_path )   Note one should still check whether  trj_path  is  None  and do  try except  for  traj.read_traj .  Another useful helper function to load both  cms_model  and trajectory is  read_cms_and_traj  from schrodinger.application.desmond.packages import traj_util\n\ntry:\n    _, cms_model, trj = traj_util.read_cms_and_traj(cmsfile)\nexcept traj_util.TrajectoryUnreadableError as err:\n    print(err)\n    sys.exit(1)", 
            "title": "load both cms file and trajectory in case trajectory path is not specified"
        }, 
        {
            "location": "/paradigms/#extract-structure-once-and-per-frame-update-coordinates-instead-of-per-frame-update-full-system-ct-and-extract-structure", 
            "text": "Note that although one can get the full system ct per frame in new trajectory infrastructure, it is likely the inefficient approach.\nIn most cases, the user does not need to track the full system ct over the frames.\nInstead, only specific group of atoms or molecules needs to be tracked over the frames.\nIn these situations, it is more efficient to   extract the atoms or molecules into a structure once  keep updating (or maybe only read) the coordinates of the selected atoms or molecules frame by frame   If the analysis is fully geometric, then the structure extraction can be avoided as well.  Here is an example  import   schrodinger.application.desmond.packages.topo   as   topo  import   schrodinger.application.desmond.packages.traj   as   traj  _ ,   cms_model   =   topo . read_cms ( cms_filename )  tr   =   traj . read_traj ( trajectory_directory )  protein_aids   =   cms_model . select_atom ( protein_asl )  protein_gids   =   topo . aids2gids ( cms_model ,   protein_aids , \n                               include_pseudoatoms = False )  protein_st   =   cms_model . extract ( protein_aids )  for   fr   in   tr : \n     protein_st . setXYZ ( fr . pos ( protein_gids )) \n     # what needs to be done on the protein structure \n     ...   This is better than  _ ,   cms_model   =   topo . read_cms ( cms_filename )  tr   =   traj . read_traj ( trajectory_directory )  protein_aids   =   cms_model . select_atom ( protein_asl )  for   fr   in   tr : \n     updated_cms   =   topo . update_fsys_ct ( cms_model ,   fr ) \n     protein_st   =   updated_cms . extract ( protein_aids ) \n     # what needs to be done on the protein structure \n     ...", 
            "title": "extract structure once and per frame update coordinates instead of per frame update full system ct and extract structure"
        }, 
        {
            "location": "/paradigms/#try-avoid-unwrap-coordinates-around-periodic-boundary-conditions-yourself", 
            "text": "There are mechanisms in the new trajectory infrastructure to do these unwrapping for you. The relevant analyzer classes are   basic geometric operations  Angle  Distance  Torsion  Vector    CenterOf  Centroid  CoC : center of charge  Com : center of mass     You can even measure geometric quantity between (among) center of mass objects/atoms (see example below), etc.  from   schrodinger.application.desmond.packages   import   analysis  from   schrodinger.application.desmond.packages   import   traj  from   schrodinger.application.desmond.packages   import   topo  # load data  msys_model ,   cms_model   =   topo . read_cms ( FNAME )  tr   =   traj . read_traj ( TRJ_FNAME )  # define analyzers  analyzer1   =   analysis . Com ( msys_model ,   cms_model ,   asl = my_asl )  ana_vector   =   analysis . Vector ( msys_model ,   cms_model ,   1 ,   10 )  analyzer3   =   analysis . ProtLigInter ( msys_model ,   cms_model ,   protein ,   m.n 2 )  s5   =   analysis . Com ( self . msys_model ,   self . cms_model ,   asl = not atom.num 17 )    # this doesn t need to be passed to analysis.analyze  dist_com_atm   =   analysis . Distance ( self . msys_model ,   self . cms_model ,   s5 ,   10 )  # compute result  results   =   analysis . analyze ( tr ,   analyzer1 ,   ana_vector ,   analyzer3 ,   dist_com_atm )   If you have to unwrap yourself, use the  analysis.Pbc  class. Also note that the simulation box may change from frame to frame, e.g. in NPT systems. Thus the  analysis.Pbc  object needs to be updated frame by frame.  Note that the  circular mean algorithm  is used to calculate geometric centers.\nThus it will fail if both of the following conditions apply\n* the selected atoms have a spatial extent comparable to the simulation box\n* the selected atoms do not form a blob-like shape (e.g., dumbbell)", 
            "title": "try avoid unwrap coordinates around periodic boundary conditions yourself"
        }, 
        {
            "location": "/paradigms/#analyze-all-together-instead-of-one-by-one", 
            "text": "If multiple analyzers can share some intermediate calculations, \nthere is a good chance that the new trajectory analysis framework calculates these intermediate results only once.\nThus it is more efficient to call  analysis.analyze  with all analyzers together instead of calling  analysis.analyze  multiple times.  Thus results   =   analysis . analyze ( tr ,   analyzer1 ,   analyzer2 ,   analyzer3 )    is better than result1   =   analysis . analyze ( tr ,   analyzer1 )  result2   =   analysis . analyze ( tr ,   analyzer2 )  result3   =   analysis . analyze ( tr ,   analyzer3 )", 
            "title": "analyze all together instead of one by one"
        }, 
        {
            "location": "/paradigms/#testing", 
            "text": "The new trajectory modules are in the desmond package.\nThus if you are working on a non-desmond repo and uses trajectory stuff, test has to be written in the following way   use  test_marker.require_product('desmond')  lazy import the trajectory handling modules   import   pytest  # Lazy import, in case desmond is not installed  mf   =   None  @pytest.fixture ( scope = module ,   autouse = True )  def   import_my_file (): \n     global   mf \n     import   my_file   as   mf", 
            "title": "testing"
        }, 
        {
            "location": "/correspondence/", 
            "text": "access structure\n\n\nold\n\nimport\n \nschrodinger.trajectory.cmsstructure\n \nas\n \ncmsstructure\n\n\nimport\n \nschrodinger.structutils.analyze\n \nas\n \nanalyze\n\n\n\ncms_st\n \n=\n \ncmsstructure\n.\nread_cms\n(\nmodel_fname\n)\n\n\nfor\n \na\n \nin\n \ncms_st\n.\natom\n:\n\n    \nprint\n(\na\n.\nindex\n)\n\n\nligand_aids\n \n=\n \nanalyze\n.\nevaluate_asl\n(\ncms_st\n,\n \nligand_asl\n)\n\n\n\n\nnew\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nmodel_fname\n)\n\n\nfor\n \na\n \nin\n \ncms_model\n.\natom\n:\n\n    \nprint\n(\na\n.\nindex\n)\n\n\nligand_aids\n \n=\n \ncms_model\n.\nselect_atom\n(\nligand_asl\n)\n\n\n\n\n\n\nNote that \nanalyze.evaluate_asl\n does not respect PBC whereas \ncms_model.select_atom\n does.\n\n\naccess trajectory\n\n\nold\n\nfrom\n \nschrodinger.trajectory.desmondsimulation\n \nimport\n \nChorusSimulation\n\n\nfrom\n \nschrodinger.infra\n \nimport\n \ndesmond\n\n\n\ntr\n \n=\n \ndesmond\n.\ngeneric_trajectory\n(\ntrajectory_directory\n)\n\n\ndt\n \n=\n \ntr\n.\nframe_time\n(\n1\n)\n \n-\n \ntr\n.\nframe_time\n(\n0\n)\n\n\n\ncsim\n \n=\n \nChorusSimulation\n(\ncms_filename\n,\n \ntrajectory_directory\n)\n\n\nfor\n \nframe_index\n \nin\n \nxrange\n(\ncsim\n.\ntotal_frame\n):\n\n    \nfr\n \n=\n \ncsim\n.\ngetFrame\n(\nframe_index\n)\n\n    \nst\n \n=\n \nfr\n.\ngetStructure\n()\n\n\n\n\n\n\nnew\n\nimport\n \nschrodinger.application.desmond.packages.traj\n \nas\n \ntraj\n\n\nimport\n \nschrodinger.application.desmond.packages.topo\n \nas\n \ntopo\n\n\n\n_\n,\n \ncms_model\n \n=\n \ntopo\n.\nread_cms\n(\nmodel_fname\n)\n\n\ntr\n \n=\n \ntraj\n.\nread_traj\n(\ntrajectory_directory\n)\n\n\ndt\n \n=\n \ntr\n[\n1\n]\n.\ntime\n \n-\n \ntr\n[\n0\n]\n.\ntime\n\n\nfor\n \nfr\n \nin\n \ntr\n:\n\n    \nst\n \n=\n \ntopo\n.\nupdate_fsys_ct\n(\ncms_model\n,\n \nfr\n)\n.\nfsys_ct\n\n    \n# you can use st = topo.update_fsys_ct(cms_model, fr) as well\n\n    \n# since the properties of cms_model and its fsys_ct are in sync\n\n\n\n\nNote that\n\n\n\n\nalthough there is a correspondence of \nst = fr.getStructure()\n, it is likely not the way to go. See \nthis paradigm\n.\n\n\nthere are two ways to update the \ncms_model\n\n\nupdated_cms\n \n=\n \ntopo\n.\nupdate_fsys_ct\n(\ncms_model\n,\n \nfr\n)\n\n\nupdated_cms\n \n=\n \ntopo\n.\nupdate_cms\n(\ncms_model\n,\n \nfr\n)\n\n\n\n\n\n\n\n\nThe difference is that \nupdate_cms\n not only updates full system ct, but also component cts.", 
            "title": "Correspondence"
        }, 
        {
            "location": "/correspondence/#access-structure", 
            "text": "old import   schrodinger.trajectory.cmsstructure   as   cmsstructure  import   schrodinger.structutils.analyze   as   analyze  cms_st   =   cmsstructure . read_cms ( model_fname )  for   a   in   cms_st . atom : \n     print ( a . index )  ligand_aids   =   analyze . evaluate_asl ( cms_st ,   ligand_asl )  \n\nnew import   schrodinger.application.desmond.packages.topo   as   topo  _ ,   cms_model   =   topo . read_cms ( model_fname )  for   a   in   cms_model . atom : \n     print ( a . index )  ligand_aids   =   cms_model . select_atom ( ligand_asl )    Note that  analyze.evaluate_asl  does not respect PBC whereas  cms_model.select_atom  does.", 
            "title": "access structure"
        }, 
        {
            "location": "/correspondence/#access-trajectory", 
            "text": "old from   schrodinger.trajectory.desmondsimulation   import   ChorusSimulation  from   schrodinger.infra   import   desmond  tr   =   desmond . generic_trajectory ( trajectory_directory )  dt   =   tr . frame_time ( 1 )   -   tr . frame_time ( 0 )  csim   =   ChorusSimulation ( cms_filename ,   trajectory_directory )  for   frame_index   in   xrange ( csim . total_frame ): \n     fr   =   csim . getFrame ( frame_index ) \n     st   =   fr . getStructure ()    new import   schrodinger.application.desmond.packages.traj   as   traj  import   schrodinger.application.desmond.packages.topo   as   topo  _ ,   cms_model   =   topo . read_cms ( model_fname )  tr   =   traj . read_traj ( trajectory_directory )  dt   =   tr [ 1 ] . time   -   tr [ 0 ] . time  for   fr   in   tr : \n     st   =   topo . update_fsys_ct ( cms_model ,   fr ) . fsys_ct \n     # you can use st = topo.update_fsys_ct(cms_model, fr) as well \n     # since the properties of cms_model and its fsys_ct are in sync  \n\nNote that   although there is a correspondence of  st = fr.getStructure() , it is likely not the way to go. See  this paradigm .  there are two ways to update the  cms_model  updated_cms   =   topo . update_fsys_ct ( cms_model ,   fr )  updated_cms   =   topo . update_cms ( cms_model ,   fr )     The difference is that  update_cms  not only updates full system ct, but also component cts.", 
            "title": "access trajectory"
        }
    ]
}